# -*- coding: utf-8 -*-
"""dph_deconvolution_v14.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Wc3gI82USZemfqb1lb8FIIQS1V7lvcPw

# imports
"""
# %% Imports

import time
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.patches as patches

from pathlib import Path  # see https://docs.python.org/3/library/pathlib.html#basic-use

import collections

from ipywidgets import (
    interact,
    interactive,
    fixed,
    interact_manual,
    Button,
    VBox,
    HBox,
    interactive,
    interactive_output,
)
import ipywidgets as widgets


import h5py

import math
import scipy

import pandas as pd

# pip install lmfit

from lmfit import Model

# everything for deconvolution method

# Garbage Collector - use it like gc.collect() from https://stackoverflow.com/a/61193594
import gc

from scipy.signal import convolve2d as conv2

from skimage import color, data, restoration

from scipy import fftpack

from scipy.optimize import curve_fit
from scipy.optimize import brenth
from scipy.optimize import minimize_scalar
import scipy.optimize as optimize

from IPython.display import display, clear_output

import os.path

# import pickle as pl

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline




# %% """# Profile-Fitting"""


def Airy(x, w, wavelength, z, d):
    Z = (math.pi / wavelength) * w * (x - d) / z
    f = (math.pi / wavelength) * w ** 2 * 1 / z * scipy.special.jv(1, Z) / (Z)
    return f


def interference_profile_simulation(
    x, shiftx_um, wavelength_nm, z_mm, d_um, w1_um, w2_um, I_Airy1, I_Airy2, x1_um, x2_um, gamma, normfactor,
):
    # Young's double pinholes experiment simulation

    # PIXIS 1024B: 13um pixelsize, 1024px, 13.3mmx13.3mm chip size

    wavelength = wavelength_nm * 1e-9  # wavelength
    w1 = w1_um * 1e-6  # first pinhole width/diameter
    w2 = w2_um * 1e-6  # second pinhole width/diameter
    z = z_mm * 1e-3  # distance from double pinholes to detector
    d = d_um * 1e-6  # double pinhole separation

    shiftx = shiftx_um * 1e-6
    x1 = x1_um * 1e-6
    x2 = x2_um * 1e-6

    k = 2 * math.pi / wavelength
    theta = -(k * (d * (x - shiftx) / z))

    if I_Airy1 < 0:
        print("I_Airy1 negative")

    if I_Airy2 < 0:
        print("I_Airy2 negative")

    I = (
        0
        + I_Airy1 * Airy((x - shiftx), w1, wavelength, z, x1) ** 2
        + I_Airy2 * Airy((x - shiftx), w2, wavelength, z, x2) ** 2
        + 2
        * np.sqrt(I_Airy1)
        * Airy((x - shiftx), w1, wavelength, z, x1)
        * np.sqrt(I_Airy2)
        * Airy((x - shiftx), w2, wavelength, z, x2)
        * gamma
        * np.cos(theta)
    )

    I_normalized = normfactor * I / np.max(I)

    return I_normalized


def interference_profile_simulation_v2(
    x, shiftx_um, wavelength_nm, z_mm, d_um, w1_um, w2_um, I_Airy1, I_Airy2, x1_um, x2_um, gamma, normfactor, mod_sigma_um, mod_shiftx_um
):
    # Young's double pinholes experiment simulation

    # PIXIS 1024B: 13um pixelsize, 1024px, 13.3mmx13.3mm chip size

    wavelength = wavelength_nm * 1e-9  # wavelength
    w1 = w1_um * 1e-6  # first pinhole width/diameter
    w2 = w2_um * 1e-6  # second pinhole width/diameter
    z = z_mm * 1e-3  # distance from double pinholes to detector
    d = d_um * 1e-6  # double pinhole separation

    shiftx = shiftx_um * 1e-6
    mod_shiftx = mod_shiftx_um * 1e-6
    mod_sigma = mod_sigma_um * 1e-6
    x1 = x1_um * 1e-6
    x2 = x2_um * 1e-6

    k = 2 * math.pi / wavelength
    theta = -(k * (d * (x - shiftx) / z))

    if I_Airy1 < 0:
        print("I_Airy1 negative")

    if I_Airy2 < 0:
        print("I_Airy2 negative")

    I = (
        0
        + I_Airy1 * Airy((x - shiftx), w1, wavelength, z, x1) ** 2
        + I_Airy2 * Airy((x - shiftx), w2, wavelength, z, x2) ** 2
        + 2
        * np.sqrt(I_Airy1)
        * Airy((x - shiftx), w1, wavelength, z, x1)
        * np.sqrt(I_Airy2)
        * Airy((x - shiftx), w2, wavelength, z, x2)
        * gamma
        * np.cos(theta)
        * gaussian(x, 1, mod_shiftx, mod_sigma)
        # * (-1/mod_shiftx * x + 1)
    )

    I_normalized = normfactor * I / np.max(I)

    return I_normalized





def gaussian(x, amp, cen, sigma):
    """1-d gaussian: gaussian(x, amp, cen, sigma)"""
    return (amp  * np.exp(-(x-cen)**2 / (2*sigma**2)))

# How to include error bars in lmfit when fitting data to Gaussian profile?
# https://stackoverflow.com/questions/56412962/how-to-include-error-bars-in-lmfit-when-fitting-data-to-gaussian-profile

def find_sigma(x,y, dely, sigma_init, use_dely):

    mymodel = Model(gaussian)
    # sigma_init = 700
    params = mymodel.make_params(amp=1, cen=0, sigma=sigma_init)
    params['amp'].vary = False
    params['cen'].vary = False
    mymodel.set_param_hint('sigma', value=sigma_init)

    if use_dely == True:
        result = mymodel.fit(y, params, x=x, weights=np.divide([1.0],dely))       
    else:
        result = mymodel.fit(y, params, x=x)

    xi_um_fit = abs(result.params['sigma'].value)
    xi_um_fit_stderr = result.params['sigma'].stderr

    delmodel = result.eval_uncertainty()
        
    #print(result.fit_report())
    
    return (xi_um_fit, xi_um_fit_stderr)


def fit_profile(
    pixis_image_norm,
    pixis_profile_avg,
    shiftx_um,
    shiftx_um_range,
    shiftx_um_do_fit,
    wavelength_nm,
    wavelength_nm_range,
    wavelength_nm_do_fit,
    z_mm,
    z_mm_range,
    z_mm_do_fit,
    d_um,
    d_um_range,
    d_um_do_fit,
    gamma,
    gamma_range,
    gamma_do_fit,
    w1_um,
    w1_um_range,
    w1_um_do_fit,
    w2_um,
    w2_um_range,
    w2_um_do_fit,
    I_Airy1,
    I_Airy1_range,
    I_Airy1_do_fit,
    I_Airy2,
    I_Airy2_range,
    I_Airy2_do_fit,
    x1_um,
    x1_um_range,
    x1_um_do_fit,
    x2_um,
    x2_um_range,
    x2_um_do_fit,
    normfactor,
    normfactor_range,
    normfactor_do_fit,
):

    n = pixis_profile_avg.size  # number of sampling point  # number of pixels
    dX_1 = 13e-6
    xdata = np.linspace((-n / 2) * dX_1, (+n / 2 - 1) * dX_1, n)
    # ydata = pixis_profile_avg_dataset[imageid]*datafactor
    ydata = pixis_profile_avg  # defined in the cells above, still to implement: select

    fringeseparation_um = z_mm * 1e-3 * wavelength_nm * 1e-9 / (d_um * 1e-6) * 1e6
    fringeseparation_px = fringeseparation_um / 13

    # Fitting

    func = interference_profile_simulation
    mymodel = Model(func)
    # params = mymodel.make_params(shiftx_um=shiftx_um, wavelength_nm=wavelength_nm, z_mm=z_mm, d_um=d_um, w1_um=w1_um, w2_um=w2_um, I_w1=I_w1, I_w2=I_w2, I_Airy1=I_Airy1, I_Airy2=I_Airy2, x1_um=x1_um, x2_um=x2_um, gamma=gamma, a1=a1, b1=b1, c1=c1, e1=e1, a2=a2, b2=b2, c2=c2, e2=e2, normfactor = normfactor)

    mymodel.set_param_hint(
        "shiftx_um", value=shiftx_um, min=shiftx_um_range[0], max=shiftx_um_range[1], vary=shiftx_um_do_fit
    )
    mymodel.set_param_hint(
        "wavelength_nm",
        value=wavelength_nm,
        min=wavelength_nm_range[0],
        max=wavelength_nm_range[1],
        vary=wavelength_nm_do_fit,
    )
    mymodel.set_param_hint("z_mm", value=z_mm, min=z_mm_range[0], max=z_mm_range[1], vary=z_mm_do_fit)
    mymodel.set_param_hint("d_um", value=d_um, min=d_um_range[0], max=d_um_range[1], vary=d_um_do_fit)
    mymodel.set_param_hint("w1_um", value=w1_um, min=w1_um_range[0], max=w1_um_range[1], vary=w1_um_do_fit)
    mymodel.set_param_hint("w2_um", value=w2_um, min=w2_um_range[0], max=w2_um_range[1], vary=w2_um_do_fit)
    mymodel.set_param_hint("I_Airy1", value=I_Airy1, min=I_Airy1_range[0], max=I_Airy1_range[1], vary=I_Airy1_do_fit)
    mymodel.set_param_hint("I_Airy2", value=I_Airy2, min=I_Airy2_range[0], max=I_Airy2_range[1], vary=I_Airy2_do_fit)
    mymodel.set_param_hint("x1_um", value=x1_um, min=x1_um_range[0], max=x1_um_range[1], vary=x1_um_do_fit)
    mymodel.set_param_hint("x2_um", value=x2_um, min=x2_um_range[0], max=x2_um_range[1], vary=x2_um_do_fit)
    mymodel.set_param_hint("gamma", value=gamma, min=gamma_range[0], max=gamma_range[1], vary=gamma_do_fit)
    mymodel.set_param_hint(
        "normfactor", value=normfactor, min=normfactor_range[0], max=normfactor_range[1], vary=normfactor_do_fit
    )

    params = mymodel.make_params()
    result = mymodel.fit(ydata, params, x=xdata)

    return result

    # shiftx_um_fit = result.params["shiftx_um"].value
    # wavelength_nm_fit = result.params["wavelength_nm"].value
    # z_mm_fit = result.params["z_mm"].value
    # d_um_fit = result.params["d_um"].value
    # w1_um_fit = result.params["w1_um"].value
    # w2_um_fit = result.params["w2_um"].value
    # I_Airy1_fit = result.params["I_Airy1"].value
    # I_Airy2_fit = result.params["I_Airy2"].value
    # x1_um_fit = result.params["x1_um"].value
    # x2_um_fit = result.params["x2_um"].value
    # gamma_fit = result.params["gamma"].value
    # normfactor_fit = result.params["normfactor"].value

    # d_um_at_detector = x2_um_fit - x1_um_fit

    # fringeseparation_um = z_mm * 1e-3 * wavelength_nm_fit * 1e-9 / (d_um * 1e-6) * 1e6
    # fringeseparation_px = fringeseparation_um / 13




def fit_profile_v2(
    pixis_image_norm,
    pixis_profile_avg,
    shiftx_um,
    shiftx_um_range,
    shiftx_um_do_fit,
    wavelength_nm,
    wavelength_nm_range,
    wavelength_nm_do_fit,
    z_mm,
    z_mm_range,
    z_mm_do_fit,
    d_um,
    d_um_range,
    d_um_do_fit,
    gamma,
    gamma_range,
    gamma_do_fit,
    w1_um,
    w1_um_range,
    w1_um_do_fit,
    w2_um,
    w2_um_range,
    w2_um_do_fit,
    I_Airy1,
    I_Airy1_range,
    I_Airy1_do_fit,
    I_Airy2,
    I_Airy2_range,
    I_Airy2_do_fit,
    x1_um,
    x1_um_range,
    x1_um_do_fit,
    x2_um,
    x2_um_range,
    x2_um_do_fit,
    normfactor,
    normfactor_range,
    normfactor_do_fit,
    mod_sigma_um,
    mod_sigma_um_range,
    mod_sigma_um_do_fit,
    mod_shiftx_um,
    mod_shiftx_um_range,
    mod_shiftx_um_do_fit
):

    n = pixis_profile_avg.size  # number of sampling point  # number of pixels
    dX_1 = 13e-6
    xdata = np.linspace((-n / 2) * dX_1, (+n / 2 - 1) * dX_1, n)
    # ydata = pixis_profile_avg_dataset[imageid]*datafactor
    ydata = pixis_profile_avg  # defined in the cells above, still to implement: select

    fringeseparation_um = z_mm * 1e-3 * wavelength_nm * 1e-9 / (d_um * 1e-6) * 1e6
    fringeseparation_px = fringeseparation_um / 13

    # Fitting

    func = interference_profile_simulation_v2
    mymodel = Model(func)
    # params = mymodel.make_params(shiftx_um=shiftx_um, wavelength_nm=wavelength_nm, z_mm=z_mm, d_um=d_um, w1_um=w1_um, w2_um=w2_um, I_w1=I_w1, I_w2=I_w2, I_Airy1=I_Airy1, I_Airy2=I_Airy2, x1_um=x1_um, x2_um=x2_um, gamma=gamma, a1=a1, b1=b1, c1=c1, e1=e1, a2=a2, b2=b2, c2=c2, e2=e2, normfactor = normfactor)

    mymodel.set_param_hint(
        "shiftx_um", value=shiftx_um, min=shiftx_um_range[0], max=shiftx_um_range[1], vary=shiftx_um_do_fit
    )
    mymodel.set_param_hint(
        "wavelength_nm",
        value=wavelength_nm,
        min=wavelength_nm_range[0],
        max=wavelength_nm_range[1],
        vary=wavelength_nm_do_fit,
    )
    mymodel.set_param_hint("z_mm", value=z_mm, min=z_mm_range[0], max=z_mm_range[1], vary=z_mm_do_fit)
    mymodel.set_param_hint("d_um", value=d_um, min=d_um_range[0], max=d_um_range[1], vary=d_um_do_fit)
    mymodel.set_param_hint("w1_um", value=w1_um, min=w1_um_range[0], max=w1_um_range[1], vary=w1_um_do_fit)
    mymodel.set_param_hint("w2_um", value=w2_um, min=w2_um_range[0], max=w2_um_range[1], vary=w2_um_do_fit)
    mymodel.set_param_hint("I_Airy1", value=I_Airy1, min=I_Airy1_range[0], max=I_Airy1_range[1], vary=I_Airy1_do_fit)
    mymodel.set_param_hint("I_Airy2", value=I_Airy2, min=I_Airy2_range[0], max=I_Airy2_range[1], vary=I_Airy2_do_fit)
    mymodel.set_param_hint("x1_um", value=x1_um, min=x1_um_range[0], max=x1_um_range[1], vary=x1_um_do_fit)
    mymodel.set_param_hint("x2_um", value=x2_um, min=x2_um_range[0], max=x2_um_range[1], vary=x2_um_do_fit)
    mymodel.set_param_hint("gamma", value=gamma, min=gamma_range[0], max=gamma_range[1], vary=gamma_do_fit)
    mymodel.set_param_hint(
        "normfactor", value=normfactor, min=normfactor_range[0], max=normfactor_range[1], vary=normfactor_do_fit
    )
    mymodel.set_param_hint(
        "mod_sigma_um", value=mod_sigma_um, min=mod_sigma_um_range[0], max=mod_sigma_um_range[1], vary=mod_sigma_um_do_fit
    )
    mymodel.set_param_hint(
        "mod_shiftx_um", value=mod_shiftx_um, min=mod_shiftx_um_range[0], max=mod_shiftx_um_range[1], vary=mod_shiftx_um_do_fit
    )

    params = mymodel.make_params()
    result = mymodel.fit(ydata, params, x=xdata)

    return result