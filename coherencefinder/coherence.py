# -*- coding: utf-8 -*-
"""dph_deconvolution_v14.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Wc3gI82USZemfqb1lb8FIIQS1V7lvcPw

# imports
"""

import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.patches as patches

from pathlib import Path # see https://docs.python.org/3/library/pathlib.html#basic-use

import collections

from ipywidgets import interact, interactive, fixed, interact_manual, Button, VBox, HBox, interactive, interactive_output
import ipywidgets as widgets



import h5py

import math
import scipy

import pandas as pd

# pip install lmfit

from lmfit import Model

# everythinh for deconvolution method

# Garbage Collector - use it like gc.collect() from https://stackoverflow.com/a/61193594
import gc

from scipy.signal import convolve2d as conv2

from skimage import color, data, restoration

from scipy import fftpack

from scipy.optimize import curve_fit
from scipy.optimize import brenth
from scipy.optimize import minimize_scalar
import scipy.optimize as optimize

from IPython.display import display, clear_output

import os.path

# import pickle as pl

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

"""# Mount drive and define paths"""



# import_from_google_drive = False
# if import_from_google_drive == True:
#   # use data stored in own google drive location
#   from google.colab import drive

#   drive.mount('/content/gdrive', force_remount=True)
#   data_dir = Path('/content/gdrive/MyDrive/PhD/coherence/data/')
#   useful_dir = Path('/content/gdrive/MyDrive/PhD/coherence/data/useful/')
#   bgsubtracted_dir = Path('/content/gdrive/MyDrive/PhD/coherence/data/bgsubtracted/')
#   print(useful_dir)
#   scratch_dir = Path('/content/gdrive/MyDrive/PhD/coherence/data/scratch_cc/')
#   #prebgsubtracted_dir
#   #bgsubtracted_dir = Path.joinpath('/content/gdrive/MyDrive/PhD/coherence/data/scratch_cc/','bgsubtracted')

import_from_google_drive = True
if import_from_google_drive == True:
  data_dir = Path('g:/My Drive/PhD/coherence/data/')
  useful_dir = Path('g:/My Drive/PhD/coherence/data/useful/')
  bgsubtracted_dir = Path('g:/My Drive/PhD/coherence/data/bgsubtracted/')
  print(useful_dir)
  scratch_dir = Path('g:/My Drive/PhD/coherence/data/scratch_cc/')
  #prebgsubtracted_dir
  #bgsubtracted_dir = Path.joinpath('/content/gdrive/MyDrive/PhD/coherence/data/scratch_cc/','bgsubtracted')

#pwd



#pwd



"""# Load dph settings and combinations"""

dph_settings_py = str(Path.joinpath(data_dir,'dph_settings.py'))

# Commented out IPython magic to ensure Python compatibility.
# %run -i $dph_settings_py # see https://stackoverflow.com/a/14411126 and http://ipython.org/ipython-doc/dev/interactive/magics.html#magic-run
# see also https://stackoverflow.com/questions/4383571/importing-files-from-different-folder to import as a module, 
# requires however that it is located in a folder with an empty __init__.py
exec(open(dph_settings_py).read())



dph_settings_widget_layout = widgets.Layout(width='100%')
dph_settings_widget = widgets.Dropdown(options=dph_settings, layout = dph_settings_widget_layout)
#settings_widget.observe(update_settings, names='value')
display(dph_settings_widget)

dph_settings_bgsubtracted = list(bgsubtracted_dir.glob('*.h5'))

dph_settings_bgsubtracted_widget_layout = widgets.Layout(width='100%')
dph_settings_bgsubtracted_widget = widgets.Dropdown(options=dph_settings_bgsubtracted, layout = dph_settings_bgsubtracted_widget_layout)
#settings_widget.observe(update_settings, names='value')
display(dph_settings_bgsubtracted_widget)

dph_settings_bgsubtracted_widget.value

# just hdf5_filename_bg_subtracted so we can use it to search in the dataframe

dph_settings_bgsubtracted_widget.value.name

# how to get the hdf5_filename ?

with h5py.File(dph_settings_bgsubtracted_widget.label, 'r') as hdf5_file:
  hdf5_file_useful_name = hdf5_file['/hdf5_file_useful_name'][0]
  print(hdf5_file_useful_name)



"""# Load dataframes from csv"""

# dataframe of extracted from all available useful hdf5 files
df_all = pd.read_csv(Path.joinpath(scratch_dir,'df_all.csv'), index_col=0)
# maybe rename to df_hdf5_files? and then use df instead of df0?
df_all['imageid']=df_all.index

# dataframe based on the dph_settings dictionary inside dph_settings.py

#del df_settings

hdf5_file_name = []
hdf5_file_name_background = []
setting_wavelength_nm = []
setting_energy_uJ = []
setting_undulators = []
KAOS = []
separation_um = []
pinholes = []
background = []

for idx in range(len(dph_settings.keys())):
    hdf5_file_name.append(dph_settings[list(dph_settings.keys())[idx]][2])
    hdf5_file_name_background.append(dph_settings[list(dph_settings.keys())[idx]][0])
    setting_wavelength_nm.append(float(list(dph_settings.keys())[idx].split()[1][:-2]))
    setting_energy_uJ.append(int(list(dph_settings.keys())[idx].split()[2][:-2]))
    setting_undulators.append(int(list(dph_settings.keys())[idx].split()[3][:-4]))
    KAOS.append(list(dph_settings.keys())[idx].split()[4][5:])
    separation_um.append(int(list(dph_settings.keys())[idx].split()[5][:-2]))
    pinholes.append((dph_settings[list(dph_settings.keys())[idx]][3][2]))
    background.append((dph_settings[list(dph_settings.keys())[idx]][1][2]))

df_settings = pd.DataFrame({'hdf5_file_name' : hdf5_file_name,
                            'hdf5_file_name_background' : hdf5_file_name_background,
                           'setting_wavelength_nm': setting_wavelength_nm,
                           'setting_energy_uJ': setting_energy_uJ,
                           'setting_undulators': setting_undulators,
                           'KAOS': KAOS,
                           'separation_um': separation_um,
                           'pinholes': pinholes,
                           'background' : background})
df_settings

# merge dataframe of hdf5files with dataframe of settings
df0 = []
df0 = pd.merge(df_all,df_settings)
df0['timestamp_pulse_id']=df0['timestamp_pulse_id'].astype('int64')
# store this instead of df_all?

# definition of fits header columns
# needed in case we want to add new columns?
fits_header_list1 = ['bgfactor', 'pixis_rotation', 'pixis_centerx_px', 'pixis_centery_px', 'pinholes_centerx_px', 'pinholes_centery_px', 'pixis_profile_centerx_px_fit', 'pixis_profile_centery_px_fit', 'pinholes_cm_x_px', 'pinholes_cm_y_px', '_lambda_nm_fit', 'gamma_fit', 'sigma_F_gamma_um_opt', 'xi_um']
fits_header_list2 = ['shiftx_um_fit','w1_um_fit','w2_um_fit','I_Airy1_fit', 'I_Airy2_fit', 'x1_um_fit', 'x2_um_fit', 'd_um_at_detector', 'xi_x_um', 'xi_y_um']
fits_header_list3 = ['pixis_image_minus_bg_rot_cropped_counts','phcam_scalex_um_per_px','phcam_scaley_um_per_px', 'phap_diam_um', 'phap_xc_px', 'phap_yc_px', 'phap_width_px', 'phap_height_px', 
                     'pinholes_bg_avg_phi', 'pinholes_bg_avg_xc_um', 'pinholes_bg_avg_yc_um', 'pinholes_bg_avg_sx_um', 'pinholes_bg_avg_sy_um',
                    'xi_x_um_fit', 'zeta_x', 'zeta_x_fit']
fits_header_list4 = ['xi_y_um_fit', 'zeta_y', 'zeta_y_fit' ]
fits_header_list = fits_header_list1 + fits_header_list2 + fits_header_list3


#fits_header_list1 already exists in saved csv, only adding fits_header_list2, only initiate when
initiate_df_fits = True
#if initiate_df_fits == True:
    #df0 = df0.reindex(columns = df0.columns.tolist() + fits_header_list2)  
    #df_fits = df0[['timestamp_pulse_id'] + fits_header_list]

# load saved df_fits from csv
load_df_fits_csv = True
if load_df_fits_csv == True:
    df_fits = pd.read_csv(Path.joinpath(scratch_dir,'df_fits_v2.csv'), index_col=0)
    df_fits_clean = df_fits[df_fits['pixis_rotation'].notna()].drop_duplicates()
    df_fits = df_fits_clean


df0 = pd.merge(df0,df_fits, on='timestamp_pulse_id', how='outer')

df0

df0.columns



"""# load hdf5 file"""

# List all groups inside the hd5file
with h5py.File(dph_settings_bgsubtracted_widget.label, 'r') as hdf5_file:
  def printname(name):
      print(name)
  hdf5_file.visit(printname)

"""# display bgsubtracted images"""

def normalize(inputarray):
    normalized_array = inputarray / np.max(inputarray)
    return(normalized_array)

with h5py.File(dph_settings_bgsubtracted_widget.label, 'r') as hdf5_file:
  imageids = hdf5_file['/bgsubtracted/imageid'][:]
  imageid = imageids[0]
  pixis_image_norm = hdf5_file['/bgsubtracted/pixis_image_norm'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
  plt.imshow(pixis_image_norm)
  print('imageid=' + str(hdf5_file['/bgsubtracted/imageid'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]))

with h5py.File(dph_settings_bgsubtracted_widget.label, 'r') as hdf5_file:
  imageids = hdf5_file['/bgsubtracted/imageid'][:]
  imageid = imageids[0]
  pixis_profile_avg = hdf5_file['/bgsubtracted/pixis_profile_avg'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
  plt.plot(pixis_profile_avg)
  print('imageid=' + str(hdf5_file['/bgsubtracted/imageid'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]))

#reproducing 
with h5py.File(dph_settings_bgsubtracted_widget.label, 'r') as hdf5_file:
  imageids = hdf5_file['/bgsubtracted/imageid'][:]
  imageid = imageids[0]
  pixis_avg_width = 200 # use here 1 sigma of the gaussian or something similar, so it is comparable to different profile sizes
  pixis_centery_px = int(hdf5_file['/bgsubtracted/pixis_centery_px'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][0])
  print(pixis_centery_px)
  pixis_profile_avg = np.average(hdf5_file['/bgsubtracted/pixis_image_norm'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][int(pixis_centery_px-pixis_avg_width/2):int(pixis_centery_px+pixis_avg_width/2),:],axis=0)
  pixis_profile_avg = normalize(pixis_profile_avg)
  plt.plot(pixis_profile_avg)
  #why is this not giving the same profile?? in the GUI a width of 200 is defined. what was actually calculated?

"""# Profile-Fitting"""

#df = df0[(df0['hdf5_file_name'] == hdf5_file_name_image) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & df0['imageid'].isin(imageids_by_energy_hall)]

dph_settings_bgsubtracted_widget.label

pinholes = dph_settings_bgsubtracted_widget.value.name.split('(')[1][0:2]
pinholes

hdf5_file_name_useful = hdf5_file_useful_name.decode('utf-8')
hdf5_file_name_useful

hdf5_file_name = hdf5_file_useful_name.decode('utf-8').split('.h5_')[0] + '.h5'
hdf5_file_name

Path.joinpath(useful_dir,hdf5_file_name_useful)

with h5py.File(Path.joinpath(useful_dir,hdf5_file_name_useful), 'r') as hdf5_file_useful:  
  timestamps_useful = hdf5_file_useful['Timing/time stamp/fl2user1'][:]

timestamps_useful[0][0].dtype

dph_settings_bgsubtracted_widget.label

with h5py.File(dph_settings_bgsubtracted_widget.label, 'r') as hdf5_file:
  imageids = hdf5_file['/bgsubtracted/imageid'][:]
  timestamps = hdf5_file['Timing/time stamp/fl2user1'][:]



# with h5py.File(dph_settings_bgsubtracted_widget.label, 'r') as hdf5_file:
#       pixis_image_norm = hdf5_file['/bgsubtracted/pixis_image_norm'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
#       pixis_profile_avg = hdf5_file['/bgsubtracted/pixis_profile_avg'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
#       timestamp_pulse_id = hdf5_file['Timing/time stamp/fl2user1'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][2]
      
    
# pinholes = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['pinholes'].iloc[0]
# separation_um = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['separation_um'].iloc[0]
# orientation = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['orientation'].iloc[0]
# setting_wavelength_nm = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0]

# print(pinholes,separation_um, orientation, setting_wavelength_nm)







def Airy_v1(x,D,_lambda,z,d):
    Z = (1.22 * math.pi/_lambda) * D * (x-d)/z

    f = (math.pi/_lambda)*(D**2/z)* (scipy.special.jv(1,Z)/Z)
    return f

def Airy_v2(x,D,_lambda,z,d):
    Z = (2* math.pi/_lambda) * D * (x-d)/z
    f = 2 * (scipy.special.jv(1,Z)/Z)       
    return f

def Airy_v3(x,D,_lambda,z,d, a, b, c, e):
    Z = (math.pi/_lambda) * D * (x-d)/z
    f = (math.pi/_lambda) * D**2 * 1/z * (scipy.special.jv(1,b*Z)/(c*Z)) + e     
    return f

def Airy(x,D,_lambda,z,d, a, b, c, e):
    Z = (math.pi/_lambda) * c*D * (x-d)/(a*z)
    f = (math.pi/_lambda) * (c*D)**2 * 1/(a*z) * scipy.special.jv(1,b*Z)/(Z) + e  
    return f

def Airy_v5(x,D,_lambda,z,d, a, b, c, e):
    Z = (math.pi/_lambda) * D * (x-d)/(a*np.sqrt(z**2+(x-d)**2))
    f = (math.pi/_lambda) * D**2 * 1/(a*z) * scipy.special.jv(1,b*Z)/Z + e  
    return f



def simulation_test(x, shiftx_um, _lambda_nm, z_mm, d_um, w1_um,w2_um,I_w1,I_w2, I_Airy1, I_Airy2, x1_um, x2_um, gamma, a1, b1, c1, e1, a2, b2, c2, e2, normfactor):

    # Young's double pinholes experiment simulation

    #% Parameters are from Andrej's thesis

    # PIXIS 1024B: 13um pixelsize, 1024px, 13.3mmx13.3mm chip size

    _lambda = _lambda_nm*1e-9# wavelength
    w1 = w1_um*1e-6  # first slit width
    w2 = w2_um*1e-6  # second slit width
    z = z_mm*1e-3  # pinholess to detector #5896
    #gamma# degree of spatial coherence
    d = d_um*1e-6 # slit separation
    
    #R = 1 / dx# rescale factor

    #% Intensity simulation

    shiftx = shiftx_um*1e-6
    x1 = x1_um *1e-6
    x2 = x2_um *1e-6

    k = 2 * math.pi / _lambda
    theta = - (k * (d * (x-shiftx) / z))
    
    #Partial_Coherence_Factor = gamma * np.cos(theta/2)**2
    Partial_Coherence_Factor = gamma * np.cos(theta)

    # The amplitudes of the wave field in the far field:

    #Amp_1 = np.sqrt(I_w1) * Airy((x-shiftx), w1, _lambda, z, -d/2)
    #Amp_2 = np.sqrt(I_w2) * Airy((x-shiftx), w2, _lambda, z, +d/2)
    
    Amp_1 = Airy((x-shiftx), w1, _lambda, z, -d/2, a1, b1, c1, e1)
    Amp_2 = Airy((x-shiftx), w2, _lambda, z, +d/2, a2, b2, c2, e2)

    if I_Airy1 < 0:
        print('I_Airy1 negative')
        
    if I_Airy2 < 0:
        print('I_Airy2 negative')
    
    #I_D = (Amp_1**2 + Amp_2**2) + 2 * abs(Amp_1) * abs(Amp_2) * Partial_Coherence_Factor
    I_D = 0 \
    + 1 * (I_w1 * Amp_1**2 + I_w2 * Amp_2**2) \
    + 2 * np.sqrt(I_w1) * np.sqrt(I_w2) * abs(Amp_1) * abs(Amp_2) * gamma * np.cos(theta) \
    + 2 * np.sqrt(I_Airy1) * Airy((x-shiftx), w1, _lambda, z, x1, a1, b1, c1, e1)  * np.sqrt(I_Airy2) * Airy((x-shiftx), w2, _lambda, z, x2, a2, b2, c2, e2) * gamma * np.cos(theta) \
    + I_Airy1 * Airy((x-shiftx), w1, _lambda, z, x1, a1, b1, c1, e1)**2 \
    + I_Airy2 * Airy((x-shiftx), w2, _lambda, z, x2, a2, b2, c2, e2)**2
    
#      
    #+ np.sqrt(I_Airy1) * Airy((x-shiftx), w1, _lambda, z, -x1)**2 \
    #+ np.sqrt(I_Airy2) * Airy((x-shiftx), w2, _lambda, z, +x2)**2
    
    #I_D_normalized = normfactor * I_D / np.max(+ I_Airy1 * Airy((x-shiftx), w1, _lambda, z, x1, a1, b1, c1, e1)**2 + I_Airy2 * Airy((x-shiftx), w2, _lambda, z, x2, a2, b2, c2, e2)**2)
    I_D_normalized = normfactor * I_D / np.max(I_D)
    

    return I_D_normalized

# pixis_centerx_px = 508.1 + 1* 13.52
# _lambda_nm = 13.53
# gamma = 1

# w1_um = 7.2
# w2_um = 7.2

# I_w1 = 1
# I_w2 = 0.8
# I_Airy1 = 1
# I_Airy2 = 0.8

# x1_loc_px = 150.0
# x2_loc_px = 800.0

from lmfit import Model
import time



with h5py.File(dph_settings_bgsubtracted_widget.label, 'r') as hdf5_file:
  imageids = hdf5_file['/bgsubtracted/imageid'][:]

def dph_settings_bgsubtracted_widget_changed(change):
  statustext_widget.value = 'updating widgets ...'
  plotprofile_interactive_output.clear_output()
  fittingprogress_widget.value = 0
  plotprofile_active_widget.value = False
  statustext_widget.value = 'plotprofile_active_widget.value = False'
  imageid_profile_fit_widget.disabled = True
  imageid_profile_fit_widget.options = None
  with h5py.File(dph_settings_bgsubtracted_widget.label, 'r') as hdf5_file:
    imageids = hdf5_file['/bgsubtracted/imageid'][:]
    imageid_profile_fit_widget.options = imageids
    imageid_profile_fit_widget.disabled = False
    imageid = imageid_profile_fit_widget.value
    timestamp_pulse_id = hdf5_file['Timing/time stamp/fl2user1'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][2]
    pixis_centery_px = hdf5_file['/bgsubtracted/pixis_centery_px'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][0] # needed for what?
    setting_wavelength_nm = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0]
    pinholes_bg_avg_sx_um = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['pinholes_bg_avg_sx_um'].iloc[0]
    pinholes_bg_avg_sy_um = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['pinholes_bg_avg_sy_um'].iloc[0]
    ph = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['pinholes'].iloc[0]
    separation_um = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['separation_um'].iloc[0]
    orientation = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['orientation'].iloc[0]
    
  _lambda_nm_widget.value = setting_wavelength_nm
  _lambda_nm_range_widget.value = value=[_lambda_nm_widget.value-0.1, _lambda_nm_widget.value+0.1]
  d_um_widget.value = separation_um = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['separation_um'].iloc[0]
  x1_um_widget.value=-d_um_widget.value*10/2
  x2_um_widget.value=d_um_widget.value*10/2
  x1_um_range_widget.value = [-d_um_widget.value*10/2-1000, 0]
  x2_um_range_widget.value = [0, d_um_widget.value*10/2+1000]
  statustext_widget.value = 'widgets updated'
  if orientation == 'horizontal':
    textarea_widget.value = str(pinholes_bg_avg_sx_um)
  if orientation == 'vertical':
    textarea_widget.value = str(pinholes_bg_avg_sy_um)
dph_settings_bgsubtracted_widget.observe(dph_settings_bgsubtracted_widget_changed, names='value')

def plotprofile(plotprofile_active, hdf5_file_path, imageid, savefigure, save_to_df, do_textbox,
                shiftx_um, _lambda_nm, z_mm, d_um, gamma, w1_um, w2_um, I_w1, I_w2, I_Airy1, I_Airy2, x1_um, x2_um, a1, b1, c1, e1, a2, b2, c2, e2, normfactor, datafactor,
                shiftx_um_range, _lambda_nm_range, z_mm_range, d_um_range, gamma_range, w1_um_range, w2_um_range, I_w1_range, I_w2_range, I_Airy1_range, I_Airy2_range, x1_um_range, x2_um_range, a1_range, b1_range, c1_range, e1_range, a2_range, b2_range, c2_range, e2_range, normfactor_range,
                shiftx_um_do_fit, _lambda_nm_do_fit, z_mm_do_fit, d_um_do_fit, gamma_do_fit, w1_um_do_fit, w2_um_do_fit, I_w1_do_fit, I_w2_do_fit, I_Airy1_do_fit, I_Airy2_do_fit, x1_um_do_fit, x2_um_do_fit, a1_do_fit, b1_do_fit, c1_do_fit, e1_do_fit, a2_do_fit, b2_do_fit, c2_do_fit, e2_do_fit, normfactor_do_fit):

  if plotprofile_active == True: # workaround, so that the function is not executed while several inputs are changed
    fittingprogress_widget.bar_style = 'info'
    fittingprogress_widget.value = 0
    statustext_widget.value = 'fitting ...'
    textarea_widget.value = ''

    with h5py.File(hdf5_file_path, 'r') as hdf5_file:
      pixis_image_norm = hdf5_file['/bgsubtracted/pixis_image_norm'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
      pixis_profile_avg = hdf5_file['/bgsubtracted/pixis_profile_avg'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
      timestamp_pulse_id = hdf5_file['Timing/time stamp/fl2user1'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][2]

    ph = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['pinholes'].iloc[0]
    separation_um = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['separation_um'].iloc[0]
    orientation = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['orientation'].iloc[0]
    setting_wavelength_nm = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0]
    pinholes_bg_avg_sx_um = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['pinholes_bg_avg_sx_um'].iloc[0]
    pinholes_bg_avg_sy_um = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['pinholes_bg_avg_sy_um'].iloc[0]
    
    fittingprogress_widget.value = 2  
  #     hdf5_file_name_image = hdf5_file_name_image_widget.value
  #     dataset_image_args = dataset_image_args_widget.value
    
    # imageids_by_energy_hall = get_imageids_with_bgs(beamposition_horizontal_interval)
    imageids_by_energy_hall = imageids
    
    # if imageid == -1:
    #     beamposx = df['beam position hall horizontal pulse resolved'].mean(axis=0)
    #     beamposy = df['beam position hall vertical pulse resolved'].mean(axis=0)
    #     energy_hall_uJ = df['energy hall'].mean(axis=0)
    # else:
    #     beamposx = df[df['imageid']==imageid]['beam position hall horizontal pulse resolved']
    #     beamposy = df[df['imageid']==imageid]['beam position hall vertical pulse resolved']
    #     energy_hall_uJ = df[df['imageid']==imageid]['energy hall'].iloc[0]
    
    n = pixis_profile_avg.size # number of sampling point  # number of pixels
    dX_1 = 13e-6
    xdata = np.linspace((-n/2)*dX_1, (+n/2-1)*dX_1, n)
    # ydata = pixis_profile_avg_dataset[imageid]*datafactor
    ydata = pixis_profile_avg # defined in the cells above, still to implement: select 

    fringeseparation_um = z_mm * 1e-3 * _lambda_nm * 1e-9 / (d_um * 1e-6) * 1e6
    fringeseparation_px = fringeseparation_um / 13
        
    func = simulation_test
    mymodel = Model(func)
    #params = mymodel.make_params(shiftx_um=shiftx_um, _lambda_nm=_lambda_nm, z_mm=z_mm, d_um=d_um, w1_um=w1_um, w2_um=w2_um, I_w1=I_w1, I_w2=I_w2, I_Airy1=I_Airy1, I_Airy2=I_Airy2, x1_um=x1_um, x2_um=x2_um, gamma=gamma, a1=a1, b1=b1, c1=c1, e1=e1, a2=a2, b2=b2, c2=c2, e2=e2, normfactor = normfactor)

    mymodel.set_param_hint('shiftx_um', value=shiftx_um, min=shiftx_um_range[0], max=shiftx_um_range[1], vary=shiftx_um_do_fit)
    mymodel.set_param_hint('_lambda_nm', value=_lambda_nm, min=_lambda_nm_range[0], max=_lambda_nm_range[1], vary=_lambda_nm_do_fit)
    mymodel.set_param_hint('z_mm', value=z_mm, min=z_mm_range[0], max=z_mm_range[1], vary=z_mm_do_fit)
    mymodel.set_param_hint('d_um', value=d_um, min=d_um_range[0], max=d_um_range[1], vary=d_um_do_fit)
    mymodel.set_param_hint('w1_um', value=w1_um, min=w1_um_range[0], max=w1_um_range[1], vary=w1_um_do_fit)
    mymodel.set_param_hint('w2_um', value=w2_um, min=w2_um_range[0], max=w2_um_range[1], vary=w2_um_do_fit)
    mymodel.set_param_hint('I_w1', value=I_w1, min=I_w1_range[0], max=I_w1_range[1], vary=I_w1_do_fit)
    mymodel.set_param_hint('I_w2', value=I_w2, min=I_w2_range[0], max=I_w2_range[1], vary=I_w2_do_fit)
    mymodel.set_param_hint('I_Airy1', value=I_Airy1, min=I_Airy1_range[0], max=I_Airy1_range[1], vary=I_Airy1_do_fit)
    mymodel.set_param_hint('I_Airy2', value=I_Airy2, min=I_Airy2_range[0], max=I_Airy2_range[1], vary=I_Airy2_do_fit)
    mymodel.set_param_hint('x1_um', value=x1_um, min=x1_um_range[0], max=x1_um_range[1], vary=x1_um_do_fit)
    mymodel.set_param_hint('x2_um', value=x2_um, min=x2_um_range[0], max=x2_um_range[1], vary=x2_um_do_fit)
    mymodel.set_param_hint('gamma', value=gamma, min=gamma_range[0], max=gamma_range[1], vary=gamma_do_fit)
    mymodel.set_param_hint('a1', value=a1, min=a1_range[0], max=a1_range[1], vary=a1_do_fit)
    mymodel.set_param_hint('b1', value=b1, min=b1_range[0], max=b1_range[1], vary=b1_do_fit)
    mymodel.set_param_hint('c1', value=c1, min=c1_range[0], max=c1_range[1], vary=c1_do_fit)
    mymodel.set_param_hint('e1', value=e1, min=e1_range[0], max=e1_range[1], vary=e1_do_fit)
    mymodel.set_param_hint('a2', value=a2, min=a2_range[0], max=a2_range[1], vary=a2_do_fit)
    mymodel.set_param_hint('b2', value=b2, min=b2_range[0], max=b2_range[1], vary=b2_do_fit)
    mymodel.set_param_hint('c2', value=c2, min=c2_range[0], max=c2_range[1], vary=c2_do_fit)
    mymodel.set_param_hint('e2', value=e2, min=e2_range[0], max=e2_range[1], vary=e2_do_fit)
    mymodel.set_param_hint('normfactor', value=normfactor, min=normfactor_range[0], max=normfactor_range[1], vary=normfactor_do_fit)
    
    
    params = mymodel.make_params()
    
  #     params['shiftx_um'].vary = shiftx_um_do_fit
  #     params['_lambda_nm'].vary = _lambda_nm_do_fit
  #     params['z_mm'].vary = z_mm_do_fit
  #     params['d_um'].vary = d_um_do_fit
  #     params['w1_um'].vary = w1_um_do_fit
  #     params['w2_um'].vary = w2_um_do_fit
  #     params['I_w1'].vary = I_w1_do_fit
  #     params['I_w2'].vary = I_w2_do_fit
  #     params['I_Airy1'].vary = I_Airy1_do_fit
  #     params['I_Airy2'].vary = I_Airy2_do_fit
  #     params['x1_um'].vary = x1_um_do_fit
  #     params['x2_um'].vary = x2_um_do_fit
  #     params['gamma'].vary = gamma_do_fit
  #     params['a1'].vary = a1_do_fit
  #     params['b1'].vary = b1_do_fit
  #     params['c1'].vary = c1_do_fit
  #     params['e1'].vary = e1_do_fit
  #     params['a2'].vary = a2_do_fit
  #     params['b2'].vary = b2_do_fit
  #     params['c2'].vary = c2_do_fit
  #     params['e2'].vary = e2_do_fit
  #     params['normfactor'].vary = normfactor_do_fit
    
  #     params['w1_um'].min = 10
  #     params['w2_um'].min = 10
  #     params['I_Airy1'].min = 0
  #     params['I_Airy2'].min = 0
  #     params['gamma'].min = 0
    

    
    
    
    
    
    

    
    result = mymodel.fit(ydata, params, x=xdata)
    
    shiftx_um_fit = result.params['shiftx_um'].value
    _lambda_nm_fit = result.params['_lambda_nm'].value
    z_mm_fit = result.params['z_mm'].value
    d_um_fit = result.params['d_um'].value
    w1_um_fit = result.params['w1_um'].value
    w2_um_fit = result.params['w2_um'].value
    I_w1_fit = result.params['I_w1'].value
    I_w2_fit = result.params['I_w2'].value
    I_Airy1_fit = result.params['I_Airy1'].value
    I_Airy2_fit = result.params['I_Airy2'].value
    x1_um_fit = result.params['x1_um'].value
    x2_um_fit = result.params['x2_um'].value
    gamma_fit = result.params['gamma'].value
    a1_fit = result.params['a1'].value
    b1_fit = result.params['b1'].value
    c1_fit = result.params['c1'].value
    e1_fit = result.params['e1'].value
    a2_fit = result.params['a2'].value
    b2_fit = result.params['b2'].value
    c2_fit = result.params['c2'].value
    e2_fit = result.params['e2'].value
    normfactor_fit = result.params['normfactor'].value
    
    d_um_at_detector = (x2_um_fit - x1_um_fit)
    
    fringeseparation_um = z_mm * 1e-3 * _lambda_nm_fit * 1e-9 / (d_um * 1e-6) * 1e6
    fringeseparation_px = fringeseparation_um / 13
    #print('fringeseparation_px=' + str(round(fringeseparation_px,2)))

    textarea_widget.value = result.fit_report()

    fittingprogress_widget.value = 8
    statustext_widget.value = 'Generating Plot ...'
    
    
  #     fig=plt.figure(figsize=(11.69,8.27), dpi= 150, facecolor='w', edgecolor='k')  # A4 sheet in landscape
    fig = plt.figure(constrained_layout=False, figsize=(8.27,11.69), dpi=150)

    gs = gridspec.GridSpec(2, 1, figure=fig, height_ratios=[1,2])
    gs.update(hspace=0.1)
    
    
  #     ax2 = plt.subplot(2,1,2)
    ax10 = fig.add_subplot(gs[1, 0])
    
    im_ax10 = ax10.imshow(pixis_image_norm, origin='lower', interpolation='nearest', aspect='auto', cmap='jet', vmin=0, vmax=1, extent=((-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3, -n/2*dX_1*1e3, (+n/2-1)*dX_1*1e3))
    
    #fig.colorbar(im_ax2, ax=ax2, pad=0.05, fraction=0.1, shrink=1.00, aspect=20, orientation='horizontal')

    
    ax10.add_patch(
        patches.Rectangle(
        ((-n/2)*dX_1*1e3, 
        (int(round(pixis_centery_px))-n/2-pixis_avg_width/2)*dX_1*1e3),
        n*dX_1*1e3,
        pixis_avg_width*dX_1*1e3,
        color = 'w',
        linestyle = '-',
        alpha = 0.8,
        fill=False      # remove background
        )
    )


    ax10.set_xlabel('x / mm', fontsize = 14)
    ax10.set_ylabel('y / mm', fontsize = 14)
    ax10.grid(color='w', linewidth=1, alpha=0.5, linestyle='--', which='major')
    
    
    ax00 = fig.add_subplot(gs[0, 0], sharex=ax10)
  #     ax = plt.subplot(2,1,1)
    
  #     plt.plot(list(range(pixis_profile_avg.size)),ydata, color='r', linewidth=2)
  #     plt.plot(list(range(pixis_profile_avg.size)),result.best_fit, color='b', linewidth=0.5)
    ax00.plot(xdata*1e3,ydata, color='r', linewidth=2, label='data')
    ax00.plot(xdata*1e3,result.best_fit, color='b', linewidth=0.5, label='fit')
    
    Airy1 = [I_Airy1_fit * Airy((x-shiftx_um_fit*1e-6), w1_um_fit*1e-6, _lambda_nm_fit*1e-9, z_mm_fit*1e-3, x1_um_fit*1e-6, a1_fit, b1_fit, c1_fit, e1_fit)**2 for x in xdata]
    Airy1 = normalize(Airy1) / I_Airy2_fit
    Airy2 = [I_Airy2_fit * Airy((x-shiftx_um_fit*1e-6), w2_um_fit*1e-6, _lambda_nm_fit*1e-9, z_mm_fit*1e-3, x2_um_fit*1e-6, a2_fit, b2_fit, c2_fit, e2_fit)**2 for x in xdata]
    Airy2 = normalize(Airy2)
    
    do_plot_Airys = False
    if do_plot_Airys == True:
        plt.plot(xdata*1e3, Airy1, color='k', label='Airy1', linewidth=1)
        plt.plot(xdata*1e3, Airy2, color='grey', label='Airy2', linewidth=1)
    
    #plt.vlines([x1_loc_px_fit, pixis_centerx_px, x2_loc_px_fit],0,1)
    ax00.vlines([(shiftx_um_fit+x1_um_fit)*1e-3, shiftx_um_fit*1e-3, (shiftx_um_fit+x2_um_fit)*1e-3],0,0.1)
  #     ax00.annotate('xshift',
  #                xy=((shiftx_um_fit)*1e-3,0), xycoords='data',
  #                xytext=(0,-20), textcoords='offset points',
  #                 bbox=dict(boxstyle="round", fc="w"),
  #                 arrowprops=dict(arrowstyle="->"))
    ax00.annotate('$x_2$',
                xy=((shiftx_um_fit+x2_um_fit)*1e-3,0), xycoords='data',
                xytext=(0,-20), textcoords='offset points',
                bbox=dict(boxstyle="round", fc="w"),
                arrowprops=dict(arrowstyle="->"))
    ax00.annotate('$x_1$',
                xy=((shiftx_um_fit+x1_um_fit)*1e-3,0), xycoords='data',
                xytext=(0,-20), textcoords='offset points',
                bbox=dict(boxstyle="round", fc="w"),
                arrowprops=dict(arrowstyle="->"))

    #plt.hlines(0,0,n)
    
    textstr = '\n'.join((
        r'imageid=%.2f' % (imageid, ),
        r'shiftx_um=%.2f' % (result.params['shiftx_um'].value, ),
        r'$\lambda=%.2f$nm' % (result.params['_lambda_nm'].value, ),
        r'fringesepar_um=%.2f' % (fringeseparation_um, ),
        r'w1_um=%.2f' % (result.params['w1_um'].value, ),
        r'w2_um=%.2f' % (result.params['w2_um'].value, ),
        r'I_Airy1=%.2f' % (result.params['I_Airy1'].value, ),
        r'I_Airy2=%.2f' % (result.params['I_Airy2'].value, ),
        r'x1_um=%.2f' % (x1_um_fit, ),
        r'x2_um=%.2f' % (x2_um_fit, ),
        r'$\gamma=%.2f$' % (result.params['gamma'].value, ),
        r'a1=%.2f' % (result.params['a1'].value, ),
        r'a2=%.2f' % (result.params['a2'].value, ),
        r'b1=%.2f' % (result.params['b1'].value, ),
        r'b2=%.2f' % (result.params['b2'].value, ),
        r'c1=%.2f' % (result.params['c1'].value, ),
        r'c2=%.2f' % (result.params['c2'].value, ),
        r'e1=%.2f*1e-6' % (result.params['e1'].value*1e6, ),
        r'e2=%.2f*1e-6' % (result.params['e2'].value*1e6, ),
        r'normfactor=%.2f' % (result.params['normfactor'].value, ),
        r'd_um_at_detector=%.2f' % (d_um_at_detector, )))
    
    # these are matplotlib.patch.Patch properties
    props = dict(boxstyle='round', facecolor='wheat', alpha=0.5)

    # place a text box in upper left in axes coords
    
    if do_textbox == True:
        ax.text(1, 0.95, textstr, transform=ax.transAxes, fontsize=6,
                verticalalignment='top', bbox=props)
    
    ax00.set_xlim([(-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3])
    ax00.set_ylim([0, 1])
    
    ax00.set_ylabel('Intensity / a.u.', fontsize = 14)
    ax00.legend()

    textstr = ' '.join((
        'ph-'+ph+'.id'+str(int(imageid)),
        r'$\lambda=%.2f$nm' % (result.params['_lambda_nm'].value, ),
        orientation,
        '$d$='+str(int(separation_um))+'um',
        r'$d_{det}$=%.2fum' % (d_um_at_detector, ),
        '\n',
        r'$w_1$=%.2fum' % (result.params['w1_um'].value, ),
        r'$w_2$=%.2fum' % (result.params['w2_um'].value, ),
        r'$I_1$=%.2f' % (result.params['I_Airy1'].value, ),
        r'$I_2=$%.2f' % (result.params['I_Airy2'].value, ),
        r'$\gamma=%.2f$' % (result.params['gamma'].value, ))
        )
    ax00.set_title(textstr, fontsize=10)
    
    



    if savefigure == True:
        savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name
        if os.path.isdir(savefigure_dir) == False:
            os.mkdir(savefigure_dir)
        #savefigure_dir = str(scratch_dir) + '/' + hdf5_file_name_image + '_ph_'+str(ph) + '_d_'+str(separation_um)
        savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name + '/' + 'profilewidth_px_' + str(int(pixis_avg_width)) + '_' + 'bg_intervall_um_' + str(int(beamposition_horizontal_interval))
        if os.path.isdir(savefigure_dir) == False:
            os.mkdir(savefigure_dir)
        savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name + '/' + 'profilewidth_px_' + str(int(pixis_avg_width)) + '_' + 'bg_intervall_um_' + str(int(beamposition_horizontal_interval)) + '/profiles_fit/'
        if os.path.isdir(savefigure_dir) == False:
            os.mkdir(savefigure_dir)
        plt.savefig(savefigure_dir + '/' + 'profiles_fit_' + hdf5_file_name_image_widget.value \
            + '_ph_'+str(ph) \
            + '_d_'+str(separation_um) \
            + '_E_' + str(format(energy_hall_uJ, '.4f')).zfill(6)  \
            + '_image_'+str(imageid) \
            + '.png', dpi=300, facecolor='w', edgecolor='w',
        orientation='portrait', papertype=None, format=None,
        transparent=False, bbox_inches=None, pad_inches=0.1,
        frameon=None)
        plt.savefig(savefigure_dir + '/' + 'profiles_fit_' + hdf5_file_name_image_widget.value \
            + '_ph_'+str(ph) \
            + '_d_'+str(separation_um) \
            + '_E_' + str(format(energy_hall_uJ, '.4f')).zfill(6)  \
            + '_image_'+str(imageid) \
            + '.pdf', dpi=None, facecolor='w', edgecolor='w',
        orientation='portrait', papertype=None, format=None,
        transparent=False, bbox_inches=None, pad_inches=0.1,
        frameon=None)
        
    # if save_to_df == True:
    #     df0.loc[((df0['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & (df0['imageid']==imageid)), 'gamma_fit'] = gamma_fit
    #     df0.loc[((df0['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & (df0['imageid']==imageid)), '_lambda_nm_fit'] = _lambda_nm_fit
    #     df0.loc[((df0['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & (df0['imageid']==imageid)), 'd_um_at_detector'] = d_um_at_detector
    #     df0.loc[((df0['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & (df0['imageid']==imageid)), 'I_Airy1_fit'] = I_Airy1_fit
    #     df0.loc[((df0['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & (df0['imageid']==imageid)), 'I_Airy2_fit'] = I_Airy2_fit
    #     df0.loc[((df0['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & (df0['imageid']==imageid)), 'w1_um_fit'] = w1_um_fit
    #     df0.loc[((df0['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & (df0['imageid']==imageid)), 'w2_um_fit'] = w2_um_fit
    #     df0.loc[((df0['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & (df0['imageid']==imageid)), 'shiftx_um_fit'] = shiftx_um_fit
    #     df0.loc[((df0['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & (df0['imageid']==imageid)), 'x1_um_fit'] = x1_um_fit
    #     df0.loc[((df0['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & (df0['imageid']==imageid)), 'x2_um_fit'] = x2_um_fit
    
    
    
    plt.show()
    fittingprogress_widget.value = 10
    fittingprogress_widget.bar_style = 'success'
    statustext_widget.value = 'done'
      
    #print(gamma_fit)
    

n = pixis_profile_avg.size # number of sampling point  # number of pixels    


fittingprogress_widget = widgets.IntProgress(
    value=0,
    min=0,
    max=10,
    step=1,
    description='Progress:',
    bar_style='success', # 'success', 'info', 'warning', 'danger' or ''
    orientation='horizontal'
)

statustext_widget = widgets.Text(
    value='',
    placeholder='status',
    description='',
    disabled=False
)

plotprofile_active_widget = widgets.Checkbox(
    value=False,
    description='active',
    disabled=False
)

imageid_profile_fit_widget = widgets.Dropdown(
    # options=imageid_widget.options,
    options=imageids,
    description='imageid:',
    disabled=False,
)

savefigure_profile_fit_widget = widgets.Checkbox(
    value=False,
    description='savefigure',
    disabled=False
)

save_to_df_widget = widgets.Checkbox(
    value=False,
    description='save_to_df',
    disabled=False
)

do_textbox_widget = widgets.Checkbox(
    value=False,
    description='do_textbox',
    disabled=False
)

textarea_widget = widgets.Textarea(
    value='info',
    placeholder='Type something',
    description='Fitting:',
    disabled=False
)

shiftx_um_widget = widgets.FloatSlider(min=-n/2*13, max=n/2*13, value=477, step=1, description='shiftx_um')
# _lambda_nm_widget = widgets.FloatSlider(value=_lambda_widget.value, description='_lambda_nm')
_lambda_nm_widget = widgets.FloatSlider(value=8.0, description='_lambda_nm')
z_mm_widget = widgets.FloatSlider(min=5000.0, max=6000.0, value=5781.0, description='z_mm')
# d_um_widget = widgets.FloatSlider(min=107, max= 1337, value=d_um_widget.value, description='d_um')
d_um_widget = widgets.FloatSlider(min=107, max= 1337, value=215.0, description='d_um')
gamma_widget = widgets.FloatSlider(min=0, max=2.0, value=0.8, description='gamma') 
w1_um_widget = widgets.FloatSlider(min=8, max=16, value=11.00, description='w1_um') 
w2_um_widget = widgets.FloatSlider(min=8, max=16, value=11.00, description='w2_um')
I_w1_widget = widgets.FloatSlider(min=0, max=10, value=0, description='I_w1')
I_w2_widget = widgets.FloatSlider(min=0, max=10, value=0, description='I_w2')
I_Airy1_widget = widgets.FloatSlider(min=0, max=10, value=1.0, description='I_Airy1') 
I_Airy2_widget = widgets.FloatSlider(min=0, max=10, value=0.8, description='I_Airy2') 
x1_um_widget = widgets.FloatSlider(min=-n*13/2-5000, max=0, value=-d_um_widget.value*10/2, step=0.1, description='x1_um') 
x2_um_widget = widgets.FloatSlider(min=0, max=2*n*13+5000, value=d_um_widget.value*10/2, step=0.1, description='x2_um')
a1_widget = widgets.FloatSlider(min=0, max=5, value=1.0, step=0.01, description='a1')
b1_widget = widgets.FloatSlider(min=0, max=5, value=1.0, step=0.01, description='b1') 
c1_widget = widgets.FloatSlider(min=0, max=5, value=1.0, step=0.01, description='c1') 
e1_widget = widgets.FloatSlider(min=0.0000, max=0.001, value=0.0, step=0.0001, description='e1', readout_format='.2e') 
a2_widget = widgets.FloatSlider(min=0, max=5, value=1.0, step=0.01, description='a2') 
b2_widget = widgets.FloatSlider(min=0, max=5, value=1.0, step=0.01, description='b2') 
c2_widget = widgets.FloatSlider(min=0, max=5, value=1.0, step=0.01, description='c2') 
e2_widget = widgets.FloatSlider(min=0.0000, max=0.0010, value=0.0, step=0.0001, description='e2', readout_format='.2e')
normfactor_widget = widgets.FloatSlider(min=0.00, max=10, value=1.0, step=0.1, description='normfactor', readout_format='.2f')
datafactor_widget = widgets.FloatSlider(min=0.00, max=10, value=1.0, step=0.1, description='datafactor', readout_format='.2f')

shiftx_um_range_widget = widgets.FloatRangeSlider(min=-n/2*13, max=n/2*13, value=[-600, 600], step=1, description='shiftx_um')
_lambda_nm_range_widget = widgets.FloatRangeSlider(min=7, max=19, value=[_lambda_nm_widget.value-0.1, _lambda_nm_widget.value+0.1], description='_lambda_nm')
z_mm_range_widget = widgets.FloatRangeSlider(min=5000.0, max=6000.0, value=[5770.0, 5790], description='z_mm')
d_um_range_widget = widgets.FloatRangeSlider(min=50, max= 1337, value=[50.0, 1337.0], description='d_um')
gamma_range_widget = widgets.FloatRangeSlider(min=0, max=2.0, value=[0.2, 1.0], description='gamma') 
w1_um_range_widget = widgets.FloatRangeSlider(min=5, max=20, value=[8, 15], description='w1_um') 
w2_um_range_widget = widgets.FloatRangeSlider(min=5, max=20, value=[8, 15], description='w2_um')
I_w1_range_widget = widgets.FloatRangeSlider(min=0, max=10, value=[0, 1.5], description='I_w1')
I_w2_range_widget = widgets.FloatRangeSlider(min=0, max=10, value=[0, 1.5], description='I_w2')
I_Airy1_range_widget = widgets.FloatRangeSlider(min=0, max=10, value=[0.2, 1.5], description='I_Airy1') 
I_Airy2_range_widget = widgets.FloatRangeSlider(min=0, max=10, value=[0.2, 5.5], description='I_Airy2') 
x1_um_range_widget = widgets.FloatRangeSlider(min=-n*13, max=0, value=[-d_um_widget.value*10/2-1000, 0], step=0.1, description='x1_um') 
x2_um_range_widget = widgets.FloatRangeSlider(min=0, max=n*13, value=[0, d_um_widget.value*10/2+1000], step=0.1, description='x2_um')
a1_range_widget = widgets.FloatRangeSlider(min=0, max=5, value=[0, 5], step=0.01, description='a1')
b1_range_widget = widgets.FloatRangeSlider(min=0, max=5, value=[0, 5], step=0.01, description='b1') 
c1_range_widget = widgets.FloatRangeSlider(min=0, max=5, value=[0, 5], step=0.01, description='c1') 
e1_range_widget = widgets.FloatRangeSlider(min=0.0000, max=0.001, value=[0.0000, 0.0010], step=0.0001, description='e1', readout_format='.2e') 
a2_range_widget = widgets.FloatRangeSlider(min=0, max=5, value=[0, 5], step=0.01, description='a2') 
b2_range_widget = widgets.FloatRangeSlider(min=0, max=5, value=[0, 5], step=0.01, description='b2') 
c2_range_widget = widgets.FloatRangeSlider(min=0, max=5, value=[0, 5], step=0.01, description='c2') 
e2_range_widget = widgets.FloatRangeSlider(min=0.0000, max=0.0010, value=[0.0000, 0.0010], step=0.0001, description='e2', readout_format='.2e')
normfactor_range_widget = widgets.FloatRangeSlider(min=0, max=10, value=[0.5, 1.5], step=0.01, description='normfactor', readout_format='.2f')

shiftx_um_do_fit_widget = widgets.Checkbox(value=True, description='fit')
_lambda_nm_do_fit_widget = widgets.Checkbox(value=True, description='fit')
z_mm_do_fit_widget = widgets.Checkbox(value=False, description='fit')
d_um_do_fit_widget = widgets.Checkbox(value=False, description='fit')
gamma_do_fit_widget = widgets.Checkbox(value=True, description='fit')
w1_um_do_fit_widget = widgets.Checkbox(value=True, description='fit') 
w2_um_do_fit_widget = widgets.Checkbox(value=True, description='fit')
I_w1_do_fit_widget = widgets.Checkbox(value=False, description='fit')
I_w2_do_fit_widget = widgets.Checkbox(value=False, description='fit')
I_Airy1_do_fit_widget = widgets.Checkbox(value=False, description='fit')
I_Airy2_do_fit_widget = widgets.Checkbox(value=True, description='fit') 
x1_um_do_fit_widget = widgets.Checkbox(value=True, description='fit')
x2_um_do_fit_widget = widgets.Checkbox(value=True, description='fit')
a1_do_fit_widget = widgets.Checkbox(value=False, description='fit')
b1_do_fit_widget = widgets.Checkbox(value=False, description='fit')
c1_do_fit_widget = widgets.Checkbox(value=False, description='fit')
e1_do_fit_widget = widgets.Checkbox(value=False, description='fit')
a2_do_fit_widget = widgets.Checkbox(value=False, description='fit')
b2_do_fit_widget = widgets.Checkbox(value=False, description='fit')
c2_do_fit_widget = widgets.Checkbox(value=False, description='fit')
e2_do_fit_widget = widgets.Checkbox(value=False, description='fit')
normfactor_do_fit_widget = widgets.Checkbox(value=False, description='fit')



column0 = widgets.VBox([plotprofile_active_widget,
                        imageid_profile_fit_widget,
                       savefigure_profile_fit_widget,
                       save_to_df_widget,
                       do_textbox_widget])

column1 = widgets.VBox([shiftx_um_widget,
                        _lambda_nm_widget,
                        z_mm_widget,
                        d_um_widget,
                        gamma_widget,
                        w1_um_widget,
                        w2_um_widget,
                        I_w1_widget,
                        I_w2_widget,
                        I_Airy1_widget,
                        I_Airy2_widget,
                        x1_um_widget,
                        x2_um_widget,
                        a1_widget,
                        b1_widget,
                        c1_widget,
                        e1_widget,
                        a2_widget,
                        b2_widget,
                        c2_widget,
                        e2_widget,
                       normfactor_widget,
                       datafactor_widget])

column2 = widgets.VBox([shiftx_um_do_fit_widget,
                        _lambda_nm_do_fit_widget,
                        z_mm_do_fit_widget,
                        d_um_do_fit_widget,
                        gamma_do_fit_widget,
                        w1_um_do_fit_widget,
                        w2_um_do_fit_widget,
                        I_w1_do_fit_widget,
                        I_w2_do_fit_widget,
                        I_Airy1_do_fit_widget,
                        I_Airy2_do_fit_widget,
                        x1_um_do_fit_widget,
                        x2_um_do_fit_widget,
                        a1_do_fit_widget,
                        b1_do_fit_widget,
                        c1_do_fit_widget,
                        e1_do_fit_widget,
                        a2_do_fit_widget,
                        b2_do_fit_widget,
                        c2_do_fit_widget,
                        e2_do_fit_widget,
                       normfactor_do_fit_widget])

column3 = widgets.VBox([shiftx_um_range_widget,
                        _lambda_nm_range_widget,
                        z_mm_range_widget,
                        d_um_range_widget,
                        gamma_range_widget,
                        w1_um_range_widget,
                        w2_um_range_widget,
                        I_w1_range_widget,
                        I_w2_range_widget,
                        I_Airy1_range_widget,
                        I_Airy2_range_widget,
                        x1_um_range_widget,
                        x2_um_range_widget,
                        a1_range_widget,
                        b1_range_widget,
                        c1_range_widget,
                        e1_range_widget,
                        a2_range_widget,
                        b2_range_widget,
                        c2_range_widget,
                        e2_range_widget,
                       normfactor_range_widget])

column4 = widgets.VBox([textarea_widget])

plotprofile_interactive_input = widgets.HBox([column0, column1, column2, column3, column4])

plotprofile_interactive_output = interactive_output(plotprofile,
                                                   {
                                                        'plotprofile_active' : plotprofile_active_widget,
                                                        'hdf5_file_path' : dph_settings_bgsubtracted_widget,
                                                    'imageid' : imageid_profile_fit_widget,
                                                        'savefigure' : savefigure_profile_fit_widget,
                                                        'save_to_df' : save_to_df_widget,
                                                       'do_textbox' : do_textbox_widget,
                                                        'shiftx_um' : shiftx_um_widget,
                                                        '_lambda_nm' : _lambda_nm_widget,
                                                        'z_mm' : z_mm_widget,
                                                        'd_um' : d_um_widget,
                                                        'gamma' : gamma_widget,
                                                        'w1_um' : w1_um_widget,
                                                        'w2_um' : w2_um_widget,
                                                        'I_w1' : I_w1_widget,
                                                        'I_w2' : I_w2_widget,
                                                        'I_Airy1' : I_Airy1_widget,
                                                        'I_Airy2' : I_Airy2_widget,
                                                        'x1_um' : x1_um_widget,
                                                        'x2_um' : x2_um_widget,
                                                        'a1' : a1_widget,
                                                        'b1' : b1_widget,
                                                        'c1' : c1_widget,
                                                        'e1' : e1_widget,
                                                        'a2' : a2_widget,
                                                        'b2' : b2_widget,
                                                        'c2' : c2_widget,
                                                        'e2' : e2_widget,
                                                       'normfactor' : normfactor_widget,
                                                       'datafactor' : datafactor_widget,
                                                        'shiftx_um_range' : shiftx_um_range_widget,
                                                        '_lambda_nm_range' : _lambda_nm_range_widget,
                                                        'z_mm_range' : z_mm_range_widget,
                                                        'd_um_range' : d_um_range_widget,
                                                        'gamma_range' : gamma_range_widget,
                                                        'w1_um_range' : w1_um_range_widget,
                                                        'w2_um_range' : w2_um_range_widget,
                                                        'I_w1_range' : I_w1_range_widget,
                                                        'I_w2_range' : I_w2_range_widget,
                                                        'I_Airy1_range' : I_Airy1_range_widget,
                                                        'I_Airy2_range' : I_Airy2_range_widget,
                                                        'x1_um_range' : x1_um_range_widget,
                                                        'x2_um_range' : x2_um_range_widget,
                                                        'a1_range' : a1_range_widget,
                                                        'b1_range' : b1_range_widget,
                                                        'c1_range' : c1_range_widget,
                                                        'e1_range' : e1_range_widget,
                                                        'a2_range' : a2_range_widget,
                                                        'b2_range' : b2_range_widget,
                                                        'c2_range' : c2_range_widget,
                                                        'e2_range' : e2_range_widget,
                                                       'normfactor_range' : normfactor_range_widget,
                                                        'shiftx_um_do_fit' : shiftx_um_do_fit_widget,
                                                        '_lambda_nm_do_fit' : _lambda_nm_do_fit_widget,
                                                        'z_mm_do_fit' : z_mm_do_fit_widget,
                                                        'd_um_do_fit' : d_um_do_fit_widget,
                                                        'gamma_do_fit' : gamma_do_fit_widget,
                                                        'w1_um_do_fit' : w1_um_do_fit_widget,
                                                        'w2_um_do_fit' : w2_um_do_fit_widget,
                                                        'I_w1_do_fit' : I_w1_do_fit_widget,
                                                        'I_w2_do_fit' : I_w2_do_fit_widget,
                                                        'I_Airy1_do_fit' : I_Airy1_do_fit_widget,
                                                        'I_Airy2_do_fit' : I_Airy2_do_fit_widget,
                                                        'x1_um_do_fit' : x1_um_do_fit_widget,
                                                        'x2_um_do_fit' : x2_um_do_fit_widget,
                                                        'a1_do_fit' : a1_do_fit_widget,
                                                        'b1_do_fit' : b1_do_fit_widget,
                                                        'c1_do_fit' : c1_do_fit_widget,
                                                        'e1_do_fit' : e1_do_fit_widget,
                                                        'a2_do_fit' : a2_do_fit_widget,
                                                        'b2_do_fit' : b2_do_fit_widget,
                                                        'c2_do_fit' : c2_do_fit_widget,
                                                        'e2_do_fit' : e2_do_fit_widget,
                                                       'normfactor_do_fit' : normfactor_do_fit_widget
                                                       
                                                   })

from IPython.display import Javascript
display(Javascript('''google.colab.output.setIframeHeight(0, true, {maxHeight: 5000})''')) # https://stackoverflow.com/a/57346765

display(VBox([HBox([fittingprogress_widget,statustext_widget]),dph_settings_bgsubtracted_widget,plotprofile_interactive_input, plotprofile_interactive_output]))
dph_settings_bgsubtracted_widget_changed(None)





# next steps:
# double check centery
# load correct dataframe and use it to store determined values
# is it possible to not use the dataframe to get infos like ph and orientation? use dataframe just to store fitted values?
# review how dataframes are generated
# enable loading of each imageid

"""# Deconvolution-Method"""

def normalize(inputarray):
    normalized_array = inputarray / np.max(inputarray)
    return(normalized_array)

def get_imageids_with_bgs(beamposition_horizontal_interval):

    imageids = []
    for imageid in df_all[(df_all['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df_all['pinholes'] == dataset_image_args_widget.value[2])].sort_values('beam position hall horizontal pulse resolved')['imageid']:
        beamposition_horizontal_image = df_all[(df_all['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df_all['pinholes'] == dataset_image_args_widget.value[2])]['beam position hall horizontal pulse resolved'][imageid]
        matching_bg_indices = df_all[(df_all['hdf5_file_name'] == hdf5_file_name_bg_widget.value) & (df_all['pinholes'] == dataset_bg_args_widget.value[2]) & (df_all['beam position hall horizontal pulse resolved'] > beamposition_horizontal_image - beamposition_horizontal_interval/2 ) & (df_all['beam position hall horizontal pulse resolved'] < beamposition_horizontal_image + beamposition_horizontal_interval/2 ) ]['beam position hall horizontal pulse resolved'].index
        if matching_bg_indices.empty == False:
            imageids.append(imageid)
    
    return imageids


def get_pixis_profiles(imageid,
                       use_pixis_avg,
                       bgfactor,
                       avg_width,
                       pixis_rotation,
                       pixis_center_autofind,
                       pixis_centerx_px,
                       pixis_centery_px,
                      crop_px):

    # using global datasets ... because of the way interactive works ... 'fixed(dataset)'
    # make a wrapper for this function, where datasets are global...s
    global pixis_dataset
    #gloabl pixis_bg_std
    global pixis_bg_avg
    global pixis_image_norm
    global pinholes_bg_avg
#     global matching_bg_indices

    # Choosing image
    #imageid = 1
    
    #imageid = 4
    
    
   
    pixis_centerx_px = int(pixis_centerx_px)
    pixis_centery_px = int(pixis_centery_px)


    if use_pixis_avg == True:
        imageid = -1
    
    if imageid == -1:
        pixis_image = pixis_avg
    else:
        pixis_image = pixis_dataset[imageid]
        beamposition_horizontal_interval = beamposition_horizontal_interval
        beamposition_horizontal_image = df_all[(df_all['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df_all['pinholes'] == dataset_image_args_widget.value[2])]['beam position hall horizontal pulse resolved'][imageid]
        matching_bg_indices = df_all[(df_all['hdf5_file_name'] == hdf5_file_name_bg_widget.value) & (df_all['pinholes'] == dataset_bg_args_widget.value[2]) & (df_all['beam position hall horizontal pulse resolved'] > beamposition_horizontal_image - beamposition_horizontal_interval/2 ) & (df_all['beam position hall horizontal pulse resolved'] < beamposition_horizontal_image + beamposition_horizontal_interval/2 ) ]['beam position hall horizontal pulse resolved'].index
        
        #beamposition_horizontal_interval = beamposition_horizontal_interval
        #beamposition_horizontal_image = df_all[(df_all['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df_all['pinholes'] == dataset_image_args_widget.value[2])]['beam position hall horizontal pulse resolved'][imageid]
        #matching_bg_indices = df_all[(df_all['hdf5_file_name'] == hdf5_file_name_bg_widget.value) & (df_all['pinholes'] == dataset_bg_args_widget.value[2]) & (df_all['beam position hall horizontal pulse resolved'] > beamposition_horizontal_image - beamposition_horizontal_interval/2 ) & (df_all['beam position hall horizontal pulse resolved'] < beamposition_horizontal_image + beamposition_horizontal_interval/2 ) ]['beam position hall horizontal pulse resolved'].index
        if matching_bg_indices.empty:
            print('no matching bg for that energy!!')
            pixis_bg_avg = pixis_image
        else:
            pixis_bg_avg = np.mean(pixis_bg_dataset[matching_bg_indices], axis=0)
            pinholes_bg_avg = np.mean(pinholes_bg_dataset[matching_bg_indices], axis=0)
            if df0[(df0['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & (df0['imageid']==imageid)]['orientation'].iloc[0] == 'vertical':
                pinholes_bg_avg=ndimage.rotate(pinholes_bg_avg, 90)
            pinholes_bg_avg = np.fliplr(pinholes_bg_avg) # fliplr to match the microscope pictures
            energy_bg_mean = df_all[(df_all['hdf5_file_name'] == hdf5_file_name_bg_widget.value) & (df_all['pinholes'] == dataset_bg_args_widget.value[2])]['energy hall'][matching_bg_indices].mean(axis=0)
            energy_bg_std = df_all[(df_all['hdf5_file_name'] == hdf5_file_name_bg_widget.value) & (df_all['pinholes'] == dataset_bg_args_widget.value[2])]['energy hall'][matching_bg_indices].std(axis=0)
        
    pixis_image_minus_bg = np.subtract(pixis_image,bgfactor*pixis_bg_avg)
    if orient == 'vertical':
        pixis_image_minus_bg = ndimage.rotate(pixis_image_minus_bg, 90)

   # correct rotation and normalize, show where maximum is
    #pixis_rotation=-1
    crop = int(pixis_image.shape[0]*np.abs(np.sin(np.pi/180*pixis_rotation)))
    pixis_image_minus_bg_rot = ndimage.rotate(pixis_image_minus_bg, pixis_rotation, reshape=True)
    pixis_image_minus_bg_rot_cropped = pixis_image_minus_bg_rot[crop:-crop,crop+20:-crop]
    pixis_image_minus_bg_rot_cropped_counts = np.sum(pixis_image_minus_bg_rot_cropped)
    
    pixis_image_norm = pixis_image_minus_bg_rot_cropped
    pixis_image_norm = pixis_image_norm[0:min(pixis_image_norm.shape),0:min(pixis_image_norm.shape)]
    pixis_image_norm = normalize(pixis_image_norm)
    
    #np.where(pixis_image_norm < 0)
      
    if crop_px > 0:
        pixis_image_norm = pixis_image_norm[crop_px:-crop_px,crop_px:-crop_px]
        pixis_image_norm = normalize(pixis_image_norm)
    
    set_negative_to_zero = True
    if set_negative_to_zero == True:
        pixis_image_norm[np.where(pixis_image_norm < 0)] = 0
    
    pixis_bg_std_rot = ndimage.rotate(pixis_bg_std, pixis_rotation, reshape=True)
    pixis_bg_std_rot_cropped = pixis_bg_std_rot[crop:-crop,crop+20:-crop]
    pixis_bg_std_norm = pixis_bg_std_rot_cropped / np.max(pixis_image_minus_bg_rot_cropped)
    pixis_bg_std_norm = pixis_bg_std_norm[0:min(pixis_bg_std_norm.shape),0:min(pixis_bg_std_norm.shape)]
    
    if crop_px > 0:
        pixis_bg_std_norm = pixis_bg_std_norm[crop_px:-crop_px,crop_px:-crop_px]

    pixis_cts = np.sum(pixis_image_minus_bg_rot_cropped)

    if pixis_center_autofind == True:
        pixis_centerx_px = np.where(pixis_image_norm==1)[1][0]
        pixis_centery_px = np.where(pixis_image_norm==1)[0][0]
    else:
        pixis_centerx_px = int(pixis_centerx_px)
        pixis_centery_px = int(pixis_centery_px)
        
        

    pixis_profile = pixis_image_norm[ int(pixis_centery_px),:] # lineout at pixis_centery_px
    pixis_profile_avg = pixis_image_norm[ int(pixis_centery_px)-int(avg_width/2): int(pixis_centery_px)+int(avg_width/2),:]
    pixis_profile_avg = np.average(pixis_profile_avg,axis=0)
    pixis_profile_avg = pixis_profile_avg / np.max(pixis_profile_avg)  # why was this commented out?
    
    pixis_profile_avg_centerx_px = np.where(pixis_profile_avg==1)[0]
    
    pixis_profile_alongy = pixis_image_norm[ :, int(pixis_centerx_px)] # lineout at pixis_centerx_px along y
    
    n = pixis_profile_avg.size # number of sampling point  # number of pixels
    dx = 13*1e-6 # sampling # pixel size
    xdata = list(range(n))
    ydata = pixis_profile_alongy
    
    pixis_yshift_px = pixis_centery_px
    p0 = (pixis_yshift_px, 400)
    popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
    pixis_beamwidth_px = popt_gauss[1]  # this is 2 sigma!
    
    if pixis_center_autofind == True:
#         pixis_centerx_px = np.where(pixis_image_norm==1)[1][0]
#         pixis_centery_px = np.where(pixis_image_norm==1)[0][0]
        pixis_centery_px = popt_gauss[0]
        
    else:
        pixis_centerx_px = pixis_centerx_px
        pixis_centery_px = pixis_centery_px
    
    pixis_profile = pixis_image_norm[ int(pixis_centery_px),:] # lineout at pixis_centery_px
    pixis_profile_avg = pixis_image_norm[ int(pixis_centery_px)-int(avg_width/2): int(pixis_centery_px)+int(avg_width/2),:]
    pixis_profile_avg = np.average(pixis_profile_avg,axis=0)
    pixis_profile_avg = pixis_profile_avg / np.max(pixis_profile_avg)  # why was this commented out?

    
    
    pixis_bg_std_avg = pixis_bg_std_norm[ int(pixis_centery_px)-int(avg_width/2): int(pixis_centery_px)+int(avg_width/2),:]
    pixis_bg_std_avg = np.average(pixis_bg_std_avg,axis=0)
    pixis_bg_std_avg = pixis_bg_std_avg / np.max(pixis_profile_avg)  # why was this commented out?

    (pixis_cm_y_px, pixis_cm_x_px) = ndimage.measurements.center_of_mass(pixis_image_norm)

    return pixis_image_norm, pixis_bg_std_norm, pixis_bg_std_avg, pixis_profile, pixis_profile_avg, pixis_profile_avg_centerx_px, pixis_centerx_px, pixis_centery_px, pixis_profile_alongy, pixis_cts, pixis_cm_x_px, pixis_cm_y_px, pinholes_bg_avg, pixis_image_minus_bg_rot_cropped_counts

def get_pinholes_profiles(imageid,bgfactor,pinholes_rotation,centerx_px,centery_px,avg_width_alongy,avg_width_alongx):

    # using global datasets ... because of the way interactive works ... 'fixed(dataset)'
    # make a wrapper for this function, where datasets are global...s
    #global pixis_dataset
    #global pixis_bg_avg

    # Choosing image
    if imageid == -1:
        pinholes_image = np.average(pinholes_dataset, axis=0)
    else:
        pinholes_image = pinholes_dataset[imageid]
    pinholes_image_minus_bg = pinholes_image
    if orient == 'vertical':
        pinholes_image_minus_bg = ndimage.rotate(pinholes_image_minus_bg, 90)
        
    

   # correct rotation and normalize, show where maximum is

    pinholes_image_minus_bg_rot = ndimage.rotate(pinholes_image_minus_bg, pinholes_rotation)
    pinholes_image_norm = pinholes_image_minus_bg_rot / np.max(pinholes_image_minus_bg_rot)
    
    pinholes_image_norm = np.fliplr(pinholes_image_norm)

    pinholes_cts = np.sum(pinholes_image_minus_bg_rot)

#     pixis_centerx = np.where(pinholes_image_norm==1)[1][0]
#     pixis_centery = np.where(pinholes_image_norm==1)[0][0]

    pinholes_profile_alongx = pinholes_image_norm[centery_px,:]
    pinholes_profile_alongx_avg = pinholes_image_norm[centery_px-int(avg_width_alongy/2):centery_px+int(avg_width_alongy/2),:]
    pinholes_profile_alongx_avg = np.average(pinholes_profile_alongx_avg,axis=0)
    pinholes_profile_alongx_avg = pinholes_profile_alongx_avg / np.max(pinholes_profile_alongx_avg)

    pinholes_profile_alongy = pinholes_image_norm[centerx_px,:]
    pinholes_profile_alongy_avg = pinholes_image_norm[centerx_px-int(avg_width_alongx/2):centerx_px+int(avg_width_alongx/2),:]
    pinholes_profile_alongy_avg = np.average(pinholes_profile_alongy_avg,axis=0)
    pinholes_profile_alongy_avg = pinholes_profile_alongy_avg / np.max(pinholes_profile_alongy_avg)

    (pinholes_cm_y_px, pinholes_cm_x_px) = ndimage.measurements.center_of_mass(pinholes_image_norm)


    #shiftx_px = pixis_centerx - pixis_profile_avg.size/2
    #shiftx_um = shiftx_px * 13
    #widget_shiftx_um.value = shiftx_um

    return pinholes_image_norm, pinholes_profile_alongx, pinholes_profile_alongx_avg, pinholes_profile_alongy, pinholes_profile_alongx_avg, pinholes_cts, pinholes_cm_x_px, pinholes_cm_y_px

def run_fit(I_D_normalized,theta,I_D):

    I_D_fit_normalized = []
    Error = []

    for i in range(100):

        alpha = 0.01 * i # covers the range (0,1) !

        Partial_Coherence_Factor_fit = 1 + alpha * np.cos(theta)
        I_D_fit = I_D * Partial_Coherence_Factor_fit
        I_D_fit_normalized.append(I_D_fit / np.max(I_D_fit))

        # Error of fit
        chi = I_D_normalized - I_D_fit_normalized[i]
        Error.append(abs(sum(chi) / 100))

    gamma_fit = []

    for ii in range(100):

        gamma_fit.append(0.01 * ii)

        #if Error[ii] <= 10 * 1e-2:        # indicates the best fit 1e-2:
            #clear_output()

            #print('gamma_fit:', gamma_fit[ii], 'error: ', Error[ii])
            #fig = plt.figure(figsize=(12, 6))
            #ax = fig.add_subplot(1, 1, 1)

            #plt.plot(R * x, I_D_Normalized,'r', label='Simulation')
            #plt.plot(R * x[::1], I_D_fit_Normalized[ii][::1], 'r-', label='Fit')
            #ax.scatter(np.linspace(-n/2+1, n/2, n),pixis_profile_avg,s=10,marker='o', label='data', color='b')

            #plt.title('Youngs double pinholes experiment, $\gamma_{12}(0) = ' + str(gamma_fit[ii]) +'$')
            #plt.xlabel('x(px)')
            #plt.ylabel('I(x)(a.u.)')
            #plt.legend()
            #plt.xlim(300,400)
            #plt.show()

    return I_D_fit_normalized, gamma_fit, Error


##### deconvolution method #######


def gaussianbeam(x, a, m ,w, offs):
    return a*np.exp(-2*(x-m)**2/w**2) + offs

def gauss2d(x,y,sigma_x, sigma_y):
    #Gprofile = (1/(2*np.pi*sigma)) * np.exp(-(x**2+y**2)/(2*sigma**2))
    Gprofile = np.exp(-(x**2/(2*sigma_x**2)+y**2/(2*sigma_y**2)))
    return Gprofile

def convolve(star, psf):
    star_fft = fftpack.fftshift(fftpack.fftn(star))
    psf_fft = fftpack.fftshift(fftpack.fftn(psf))
    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft*psf_fft)))

def deconvolve(star, psf):
    star_fft = fftpack.fftshift(fftpack.fftn(star))
    psf_fft = fftpack.fftshift(fftpack.fftn(psf))
    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))



def mean2(x):
    y = np.sum(x) / np.size(x);
    return y

def corr2(a,b):
    a = a - mean2(a)
    b = b - mean2(b)

    r = (a*b).sum() / math.sqrt((a*a).sum() * (b*b).sum());
    return r

z = 5781 * 1e-3
z_0 = 1067 * 1e-3
z_T = z + z_0
z_eff = z * z_0 / (z_T)
dX_1 = 13 * 1e-6


def chi2_distance(histA, histB, eps = 1e-10):
    # compute the chi-squared distance
    d = 0.5 * np.sum([((a - b) ** 2) / (a + b + eps)
    for (a, b) in zip(histA, histB)])

    # return the chi-squared distance
    return d

def deconvmethod(partiallycoherent, z, dX_1, profilewidth, pixis_centery_px, wavelength, sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max, sigma_y_F_gamma_um_min, sigma_y_F_gamma_um_max, sigma_y_F_gamma_um_stepsize, sigma_x_F_gamma_um_stepsize, crop_px):

    
    #number of pixels
    n = partiallycoherent.shape[0]
    nx = n
    ny = nx


    # pixel size of the detector dX_1
    
    dY_1 = dX_1

    # 2D grid and axes at the CCD:
    #x = np.arange(-n/2, n/2, 1) * dX_1
    #y = np.arange(-n/2, n/2, 1) * dX_1
    x = np.arange(-n/2, n/2, 1)
    y = np.arange(-n/2, n/2, 1)
    X1_axis, Y1_axis = np.meshgrid(x*dX_1, y*dX_1, sparse=False)
    #X1_axis, Y1_axis = np.meshgrid(x, y, sparse=False)


    # "pixelsize" at the pinholes:
    dX_2 = wavelength*z/(n*dX_1)
    dY_2 = wavelength*z/(n*dY_1)

    # 2D grid and axes at the double pinholes:
    X2_axis, Y2_axis = np.meshgrid(x*dX_2, y*dY_2, sparse=False)


    
    #psf = gauss2d(X1_axis,Y1_axis,1.9*13*1e-6)
    #psf = psf / np.max(psf)
    #sigma_F_gamma_um = 24.7
    
    
    sigma_y_F_gamma_um_list = np.arange(sigma_y_F_gamma_um_min,sigma_y_F_gamma_um_max,sigma_y_F_gamma_um_stepsize)
    listlength = len(sigma_y_F_gamma_um_list)
    xi_x_um_list = np.array(listlength * [np.nan])
    xi_y_um_list = np.array(listlength * [np.nan])
    
    
    cor_list = np.array(listlength * [np.nan])
    cor_profiles_list = np.array(listlength * [np.nan])
    
    fullycoherent_profile_min_opt_list = np.array(listlength * [np.nan])
    fullycoherent_profile_opt_list = []
    fullycoherent_opt_list = []
    partiallycoherent_rec_list = []
    partiallycoherent_rec_profile_list = []
    partiallycoherent_rec_profile_min_list = np.array(listlength * [np.nan])
    delta_rec_min_list = np.array(listlength * [np.nan])
    delta_profiles_cropped_list = np.array(listlength * [np.nan])
    chi2distance_list = np.array(listlength * [np.nan])
    
    F_gamma_list = []
    gamma_list = []
    abs_gamma_list = []
    
    crop_px = 200
    

    
    fig = plt.figure(constrained_layout=False, figsize=(10,6), dpi=300)

    gs = gridspec.GridSpec(8, 3, figure=fig)

    ax00 = fig.add_subplot(gs[0, 0])
    ax10 = fig.add_subplot(gs[1, 0])
    ax20 = fig.add_subplot(gs[2, 0])
    ax30 = fig.add_subplot(gs[3, 0])
    ax40 = fig.add_subplot(gs[4, 0])
    ax50 = fig.add_subplot(gs[5, 0])
    ax60 = fig.add_subplot(gs[6, 0])
    ax70 = fig.add_subplot(gs[7, 0])

    ax = fig.add_subplot(gs[:, 1:])
    
    
    
    # ax = axs[0]
    # ax.plot(sigma_y_F_gamma_um_list, cor_list)
    # ax.set_ylabel('cor')

    # ax = axs[1]
    # ax.plot(sigma_y_F_gamma_um_list, cor_profiles_list)
    # ax.set_ylabel('cor profiles')

    # ax = axs[2]
    # ax.plot(sigma_y_F_gamma_um_list, chi2distance_list)
    # ax.set_ylabel('chi2distance')
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

    # ax = axs[3]
    # ax.plot(sigma_y_F_gamma_um_list, delta_rec_min_list)
    # ax.set_ylabel('delta minimum')

    # ax = axs[4]
    # ax.plot(sigma_y_F_gamma_um_list, delta_profiles_cropped_list)
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])
    # ax.set_ylabel('delta profiles cropped')

    # ax = axs[5]
    # ax.plot(sigma_y_F_gamma_um_list, xi_x_um_list)
    # ax.set_ylabel('xi_x')
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

    # ax = axs[6]
    # ax.plot(sigma_y_F_gamma_um_list, xi_y_um_list)
    # ax.set_ylabel('xi_y')
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

    # fig.tight_layout()
    # plt.xlim([sigma_y_F_gamma_um_list[0], sigma_y_F_gamma_um_list[-1]])
    # plt.show()

    z = 5781 * 1e-3
    z_0 = 1067 * 1e-3
    z_T = z + z_0
    z_eff = z * z_0 / (z_T)
    dX_1 = 13 * 1e-6

    j = 0
    index_opt = 0
    for sigma_y_F_gamma_um in sigma_y_F_gamma_um_list:
        sigma_x_F_gamma_um_list = np.arange(sigma_x_F_gamma_um_min,sigma_x_F_gamma_um_max,sigma_x_F_gamma_um_stepsize)
        sigma_x_F_gamma_um_list_length = len(sigma_x_F_gamma_um_list)
        fullycoherent_profile_min_list = np.array(sigma_x_F_gamma_um_list_length * [np.nan])
        i = 0


        partiallycoherent_profile = np.mean(partiallycoherent[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
        partiallycoherent_profile = normalize(partiallycoherent_profile)

        # see https://stackoverflow.com/a/52672859
        # fig, axs = plt.subplots(nrows=1,ncols=1, sharex=True, figsize=(5,5))
        # ax = axs
        # ax.set_ylabel('fully coherent profile min')
        # fig.tight_layout()
        
        

        ax00.cla()
        ax10.cla()
        ax20.cla()
        ax30.cla()
        ax40.cla()
        ax50.cla()
        ax60.cla()
        ax70.cla()
        
        ax00.plot(sigma_y_F_gamma_um_list, cor_list)
        ax00.set_ylabel('cor')
        ax20.axvline(sigma_y_F_gamma_um_list[index_opt])
        ax00.set_xlim([sigma_y_F_gamma_um_list[0], sigma_y_F_gamma_um_list[-1]])

        
        ax10.plot(sigma_y_F_gamma_um_list, cor_profiles_list)
        ax10.set_ylabel('cor profiles')
        ax20.axvline(sigma_y_F_gamma_um_list[index_opt])
        ax10.set_xlim([sigma_y_F_gamma_um_list[0], sigma_y_F_gamma_um_list[-1]])

        
        ax20.plot(sigma_y_F_gamma_um_list, chi2distance_list)
        ax20.set_ylabel('chi2distance')
        ax20.axvline(sigma_y_F_gamma_um_list[index_opt])
        ax20.set_xlim([sigma_y_F_gamma_um_list[0], sigma_y_F_gamma_um_list[-1]])

        
        ax30.plot(sigma_y_F_gamma_um_list, delta_rec_min_list)
        ax30.set_ylabel('delta minimum')
        ax30.set_xlim([sigma_y_F_gamma_um_list[0], sigma_y_F_gamma_um_list[-1]])

        
        ax40.plot(sigma_y_F_gamma_um_list, delta_profiles_cropped_list)
        ax40.axvline(sigma_y_F_gamma_um_list[index_opt])
        ax40.set_ylabel('delta profiles cropped')
        ax40.set_xlim([sigma_y_F_gamma_um_list[0], sigma_y_F_gamma_um_list[-1]])

        
        ax50.plot(sigma_y_F_gamma_um_list, xi_x_um_list)
        ax50.set_ylabel('xi_x')
        ax50.axvline(sigma_y_F_gamma_um_list[index_opt])
        ax50.set_xlim([sigma_y_F_gamma_um_list[0], sigma_y_F_gamma_um_list[-1]])

        
        ax60.plot(sigma_y_F_gamma_um_list, xi_y_um_list)
        ax60.set_ylabel('xi_y')
        ax60.axvline(sigma_y_F_gamma_um_list[index_opt])
        ax60.set_xlim([sigma_y_F_gamma_um_list[0], sigma_y_F_gamma_um_list[-1]])

        for sigma_x_F_gamma_um in sigma_x_F_gamma_um_list:

          sigma_x_F_gamma = sigma_x_F_gamma_um * 1e-6
          sigma_y_F_gamma = sigma_y_F_gamma_um * 1e-6
          F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma/dX_1, sigma_y_F_gamma/dX_1)
          #psf = gauss2d(X1_axis,Y1_axis,1.9)

          # Restore Image using Richardson-Lucy algorithm
          #fullycoherent = restoration.richardson_lucy(partiallycoherent, psf, 5)
          fullycoherent = restoration.wiener(partiallycoherent, F_gamma, 1)
          #fullycoherent = np.real(deconvolve(partiallycoherent, psf))



          fullycoherent = fullycoherent / np.max(fullycoherent[200:-200,200:-200])

          
          fullycoherent_profile = np.mean(fullycoherent[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
          #fullycoherent_profile = normalize(fullycoherent_profile)
          fullycoherent_profile = fullycoherent_profile / np.max(fullycoherent_profile[200:-200]) # ignore what happens on the edges

          fullycoherent_profile_min = np.min(fullycoherent_profile[200:-200]) # ignore what happens on the edges
          fullycoherent_profile_min_list[i] = fullycoherent_profile_min
          
          # print('sigma_x_F_gamma=' + str(sigma_x_F_gamma_um) + ' sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min))


         

          # fig.tight_layout()
          
          
          

          # print('second column')
          
          ax70.cla()
          ax70.plot(sigma_x_F_gamma_um_list, fullycoherent_profile_min_list)
          ax70.set_xlim([sigma_x_F_gamma_um_list[0], sigma_x_F_gamma_um_list[-1]])
          ax70.set_ylim([-0.1*np.min(partiallycoherent_profile[200:-200]), np.min(partiallycoherent_profile[200:-200])])
          ax70.axhline(0, color='k')
          # plt.title('sigma_x_F_gamma=' + str(sigma_x_F_gamma_um) + ' sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min))






          n = partiallycoherent_profile.shape[0]
          xdata = np.linspace((-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3, n)

          ax.cla()
          ax.plot(xdata, partiallycoherent_profile, 'b-', label='measured partially coherent', linewidth=1)
          ax.plot(xdata, fullycoherent_profile, 'r-', label='recovered fully coherent', linewidth=1)
          # ax.plot(xdata, partiallycoherent_rec_profile_list[index_opt], 'g-', label='recovered partially coherent', linewidth=1)
          #plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
          ax.axhline(0, color='k')
          ax.set_xlabel('x / mm', fontsize = 8)
          ax.set_ylabel('Intensity / a.u.', fontsize = 8)
          ax.set_xlim([xdata[0], xdata[-1]])
          # plt.legend()

          # plt.title('d / $\mu$m = '+str(int(separation_um)) + ' coherence length $\\xi_x$ / $\mu$m = ' + str(round(xi_x_um_list[index_opt],2)) + ' $\\xi_y$ / $\mu$m = ' + str(round(xi_y_um_list[index_opt],2)), fontsize=16)




          # see https://stackoverflow.com/a/29675706
          display(plt.gcf())
          clear_output(wait=True)
          # plt.show()

          if fullycoherent_profile_min<0:
            break
          else:
            i = i + 1

        
                


        # sigma_x_F_gamma_um_opt = sigma_x_F_gamma_um_list[i-1]
        xdata = sigma_x_F_gamma_um_list[0:i+1] # why i+1? should be i?
        ydata = fullycoherent_profile_min_list[0:i+1]
        def func(x, a, b, c):
          return a*x**2 + b*x + c
        popt_func, pcov_func = curve_fit(func, xdata, ydata)
        a = popt_func[0]
        b = popt_func[1]
        c = popt_func[2]
        
        sigma_x_F_gamma_um_opt = brenth(func, xdata[0], xdata[-1], args=(a,b,c))
        
        ax70.plot(sigma_x_F_gamma_um_list, func(sigma_x_F_gamma_um_list, a, b, c))
        ax70.axvline(sigma_x_F_gamma_um_opt)
        
        display(plt.gcf())
        clear_output(wait=True)
        # input("Press Enter to continue...")

        sigma_x_F_gamma = sigma_x_F_gamma_um_opt * 1e-6
        sigma_y_F_gamma = sigma_y_F_gamma_um * 1e-6
        F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma/dX_1, sigma_y_F_gamma/dX_1)
        #psf = gauss2d(X1_axis,Y1_axis,1.9)

        # Restore Image using Richardson-Lucy algorithm
        #fullycoherent = restoration.richardson_lucy(partiallycoherent, psf, 5)
        fullycoherent_opt = restoration.wiener(partiallycoherent, F_gamma, 1)
        #fullycoherent = np.real(deconvolve(partiallycoherent, psf))



        fullycoherent_opt = fullycoherent_opt / np.max(fullycoherent_opt[200:-200,200:-200])

        
        fullycoherent_profile_opt = np.mean(fullycoherent_opt[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
        #fullycoherent_profile = normalize(fullycoherent_profile)
        fullycoherent_profile_opt = fullycoherent_profile_opt / np.max(fullycoherent_profile_opt[200:-200]) # ignore what happens on the edges

        fullycoherent_profile_min_opt = np.min(fullycoherent_profile_opt[200:-200]) # ignore what happens on the edges
        



        # # fine-tuning in stepsize of 0.1

        # sigma_x_F_gamma_um_list = np.arange(sigma_x_F_gamma_um_opt,sigma_x_F_gamma_um_opt+1,0.05)
        # sigma_x_F_gamma_um_list_length = len(sigma_x_F_gamma_um_list)
        # fullycoherent_profile_min_list = np.array(sigma_x_F_gamma_um_list_length * [np.nan])
        # fullycoherent_list = []
        # fullycoherent_profile_list = []
        
        # i = 0
        # # fig, axs = plt.subplots(nrows=1,ncols=1, sharex=True, figsize=(5,5))
        # # ax = axs
        # for sigma_x_F_gamma_um in sigma_x_F_gamma_um_list:

        #     sigma_x_F_gamma = sigma_x_F_gamma_um * 1e-6
        #     sigma_y_F_gamma = sigma_y_F_gamma_um * 1e-6
        #     F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma/dX_1, sigma_y_F_gamma/dX_1)
        #     #psf = gauss2d(X1_axis,Y1_axis,1.9)

        #     # Restore Image using Richardson-Lucy algorithm
        #     #fullycoherent = restoration.richardson_lucy(partiallycoherent, psf, 5)
        #     fullycoherent = restoration.wiener(partiallycoherent, F_gamma, 1)
        #     #fullycoherent = np.real(deconvolve(partiallycoherent, psf))



        #     fullycoherent = fullycoherent / np.max(fullycoherent[200:-200,200:-200])
        #     fullycoherent_list.append(fullycoherent)
            

        #     fullycoherent_profile = np.mean(fullycoherent[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
        #     #fullycoherent_profile = normalize(fullycoherent_profile)
        #     fullycoherent_profile = fullycoherent_profile / np.max(fullycoherent_profile[200:-200]) # ignore what happens on the edges
        #     fullycoherent_profile_list.append(fullycoherent_profile)

        #     fullycoherent_profile_min = np.min(fullycoherent_profile[200:-200]) # ignore what happens on the edges
        #     fullycoherent_profile_min_list[i] = fullycoherent_profile_min

        #     # print('sigma_x_F_gamma=' + str(sigma_x_F_gamma_um) + ' sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min))

        #     # clear_output(wait=True)
        #     # plt.plot(sigma_x_F_gamma_um_list, fullycoherent_profile_min_list)
        #     # ax.set_ylabel('fully coherent profile min')
        #     # plt.xlim([sigma_x_F_gamma_um_list[0], sigma_x_F_gamma_um_list[-1]])
        #     # plt.ylim([0, np.min(partiallycoherent_profile[200:-200])])
        #     # # plt.title('sigma_x_F_gamma=' + str(sigma_x_F_gamma_um) + ' sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min))
        #     # plt.show()


        #     ax70.cla()
        #     ax70.plot(sigma_x_F_gamma_um_list, fullycoherent_profile_min_list)
        #     ax70.set_xlim([sigma_x_F_gamma_um_list[0], sigma_x_F_gamma_um_list[-1]])
        #     ax70.set_ylim([-0.1*np.min(partiallycoherent_profile[200:-200]), np.min(partiallycoherent_profile[200:-200])])
        #     ax70.axhline(0, color='k')
        #     # plt.title('sigma_x_F_gamma=' + str(sigma_x_F_gamma_um) + ' sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min))






        #     n = partiallycoherent_profile.shape[0]
        #     xdata = np.linspace((-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3, n)

        #     ax.cla()
        #     ax.plot(xdata, partiallycoherent_profile, 'b-', label='measured partially coherent', linewidth=1)
        #     ax.plot(xdata, fullycoherent_profile, 'r-', label='recovered fully coherent', linewidth=1)
        #     # ax.plot(xdata, partiallycoherent_rec_profile_list[index_opt], 'g-', label='recovered partially coherent', linewidth=1)
        #     #plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
        #     ax.axhline(0, color='k')
        #     ax.set_xlabel('x / mm', fontsize = 8)
        #     ax.set_ylabel('Intensity / a.u.', fontsize = 8)
        #     ax.set_xlim([xdata[0], xdata[-1]])
        #     # plt.legend()

        #     # plt.title('d / $\mu$m = '+str(int(separation_um)) + ' coherence length $\\xi_x$ / $\mu$m = ' + str(round(xi_x_um_list[index_opt],2)) + ' $\\xi_y$ / $\mu$m = ' + str(round(xi_y_um_list[index_opt],2)), fontsize=16)




        #     # see https://stackoverflow.com/a/29675706
        #     display(plt.gcf())
        #     clear_output(wait=True)
        #     # plt.show()



        #     if fullycoherent_profile_min<0:
        #         break
        #     i = i + 1
        # sigma_x_F_gamma_um_opt = sigma_x_F_gamma_um_list[i-1]
        # fullycoherent_opt = fullycoherent_list[i-1]
        fullycoherent_opt_list.append(fullycoherent_opt)
        # fullycoherent_profile_opt = fullycoherent_profile_list[i-1]
        fullycoherent_profile_opt_list.append(fullycoherent_profile_opt)
        # fullycoherent_profile_min_opt = fullycoherent_profile_min_list[i-1]
        fullycoherent_profile_min_opt_list[j] = fullycoherent_profile_min_opt
        
        F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma_um_opt*1e-6/dX_1, sigma_y_F_gamma_um*1e-6/dX_1)
        F_gamma_list.append(F_gamma)
        gamma = fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(F_gamma)))
        gamma_list.append(gamma)
    
        partiallycoherent_rec = np.abs(convolve(fullycoherent_opt,F_gamma))
        partiallycoherent_rec = normalize(partiallycoherent_rec)
        partiallycoherent_rec_list.append(partiallycoherent_rec)
        partiallycoherent_rec_profile = np.mean(partiallycoherent_rec[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
        partiallycoherent_rec_profile = normalize(partiallycoherent_rec_profile)
        partiallycoherent_rec_profile_list.append(partiallycoherent_rec_profile)
        partiallycoherent_rec_profile_min_list[j] = np.min(partiallycoherent_rec_profile)
        #partiallycoherent_rec_profile = partiallycoherent_rec_profile / partiallycoherent_rec_profile[np.where(partiallycoherent_profile == 1.0)[0][0]]
        cor = corr2(partiallycoherent, partiallycoherent_rec)
        cor_profiles = corr2(partiallycoherent_profile, partiallycoherent_rec_profile)
        cor_list[j] = corr2(partiallycoherent, partiallycoherent_rec)
        cor_profiles_list[j] = cor_profiles
        #sigma_y_F_gamma_um_opt = sigma_y_F_gamma_um

        xdata = np.linspace((-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3, n)
        ax.cla()
        ax.plot(xdata, partiallycoherent_profile, 'b-', label='measured partially coherent', linewidth=1)
        ax.plot(xdata, fullycoherent_profile_opt, 'r-', label='recovered fully coherent', linewidth=1)
        ax.plot(xdata, partiallycoherent_rec_profile_list[index_opt], 'g-', label='recovered partially coherent', linewidth=1)
        #plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
        ax.axhline(0, color='k')
        ax.set_xlabel('x / mm', fontsize = 8)
        ax.set_ylabel('Intensity / a.u.', fontsize = 8)
        ax.set_xlim([xdata[0], xdata[-1]])
        
        
        delta_profiles_cropped_list[j] = np.sum(partiallycoherent_profile[crop_px:-crop_px] - partiallycoherent_rec_profile[crop_px:-crop_px])
        
        
#         print('sigma_x_F_gamma_opt=' + str(sigma_x_F_gamma_um_opt) + 'sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min_list[i-1]) + '\\' + ' correlation partiallycohernet measurement and reconstruction = ' + str(round(cor*100,2)) + '%')


        # determine chi2 distance
        number_of_bins = 100
        hist1, bin_edges1 = np.histogram(partiallycoherent.ravel(), bins=np.linspace(0,1,number_of_bins))
        hist2, bin_edges2 = np.histogram(partiallycoherent_rec.ravel(), bins=np.linspace(0,1,number_of_bins))
        chi2distance_list[j] = chi2_distance(hist1, hist2)

        index_opt = np.where(chi2distance_list == np.nanmin(chi2distance_list))[0][0]


        # determine difference of miniumum of measured and reconstructed profile
        delta_rec_min_list[j] = np.min(partiallycoherent_rec_profile) - np.min(partiallycoherent_profile)

        

        xdata = list(range(n))
        ydata = fullycoherent[pixis_centery_px,:]
        ydata = ydata / np.max(ydata)
        

        
        abs_gamma = np.abs(gamma)
        abs_gamma = abs_gamma / np.max(abs_gamma)
        abs_gamma_list.append(abs_gamma)
        xdata = list(range(n))
        ydata = abs_gamma[int(n/2),:]
        p0 = (int(n/2), 1)
        popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
        xi_x_px = popt_gauss[1]/2
        xi_x_um = xi_x_px * dX_2 * 1e6
        xi_x_um_list[j] = xi_x_um
        
        
        xdata = list(range(n))
        ydata = abs_gamma[:,int(n/2)]
        p0 = (int(n/2), 1)
        popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
        xi_y_px = popt_gauss[1]/2
        xi_y_um = xi_y_px * dX_2 * 1e6
        xi_y_um_list[j] = xi_y_um
        
        #print('coherence length xi/um = ' + str(xi_um))



        



        j = j+1
        
        
    
    # index_opt = np.where( np.abs(partiallycoherent_rec_profile_min_list - np.min(partiallycoherent_profile)) == np.min(np.abs(partiallycoherent_rec_profile_min_list - np.min(partiallycoherent_profile)) ) )[0][0]
    
        
    A_bp = fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(np.sqrt(partiallycoherent))))  # amplitude
    I_bp = np.abs(A_bp)**2  # intensity
    
    return (partiallycoherent_profile, fullycoherent_opt_list, fullycoherent_profile_opt_list,  partiallycoherent_rec_list, partiallycoherent_rec_profile_list, partiallycoherent_rec_profile_min_list, delta_rec_min_list, delta_profiles_cropped_list, sigma_x_F_gamma_um_opt, sigma_y_F_gamma_um_list, F_gamma_list, abs_gamma_list, xi_x_um_list, xi_y_um_list, I_bp, dX_2, cor_list, cor_profiles_list, cor_profiles_list, index_opt, chi2distance_list)

"""### estimating sigma_F_gamma based on sigma_gamma"""



z = 5781 * 1e-3
z_0 = 1067 * 1e-3
z_T = z + z_0
z_eff = z * z_0 / (z_T)
dX_1 = 13 * 1e-6

wavelength = 8 * 1e-9

#number of pixels
# n = partiallycoherent.shape[0]
n = 1024
nx = n
ny = nx


# pixel size of the detector dX_1

dY_1 = dX_1

# 2D grid and axes at the CCD:
#x = np.arange(-n/2, n/2, 1) * dX_1
#y = np.arange(-n/2, n/2, 1) * dX_1
x = np.arange(-n/2, n/2, 1)
y = np.arange(-n/2, n/2, 1)
X1_axis, Y1_axis = np.meshgrid(x*dX_1, y*dX_1, sparse=False)
#X1_axis, Y1_axis = np.meshgrid(x, y, sparse=False)


# "pixelsize" at the pinholes:
dX_2 = wavelength*z/(n*dX_1)
dY_2 = wavelength*z/(n*dY_1)


# 2D grid and axes at the double pinholes:
X2_axis, Y2_axis = np.meshgrid(x*dX_2, y*dY_2, sparse=False)


#psf = gauss2d(X1_axis,Y1_axis,1.9*13*1e-6)
#psf = psf / np.max(psf)
#sigma_F_gamma_um = 24.7



# abs_gamma = np.abs(gamma)
# abs_gamma = abs_gamma / np.max(abs_gamma)
# abs_gamma_list.append(abs_gamma)
# xdata = list(range(n))
# ydata = abs_gamma[int(n/2),:]
# p0 = (int(n/2), 1)
# popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
# xi_x_px = popt_gauss[1]/2
# xi_x_um = xi_x_px * dX_2 * 1e6
# xi_x_um_list[j] = xi_x_um


# xdata = list(range(n))
# ydata = abs_gamma[:,int(n/2)]
# p0 = (int(n/2), 1)
# popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
# xi_y_px = popt_gauss[1]/2
# xi_y_um = xi_y_px * dX_2 * 1e6
# xi_y_um_list[j] = xi_y_um

# sigma_x_F_gamma = sigma_x_F_gamma_um * 1e-6
# sigma_y_F_gamma = sigma_y_F_gamma_um * 1e-6
# F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma/dX_1, sigma_y_F_gamma/dX_1)

# F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma_um*1e-6/dX_1, sigma_y_F_gamma_um*1e-6/dX_1)
# gamma = fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(F_gamma)))



# assuming coherence length xi = sigma_gamma at the pinholes
sigma_x_gamma_um = 400
sigma_y_gamma_um = sigma_x_gamma_um



# gamma at the pinholes
# gamma = gauss2d(X2_axis, Y2_axis, sigma_x_gamma_um*1e-6, sigma_y_gamma_um*1e-6)
gamma = gauss2d(X2_axis/dX_2, Y2_axis/dX_2, sigma_x_gamma_um*1e-6/dX_2, sigma_y_gamma_um*1e-6/dX_2)

xdata = list(range(n))
ydata = abs(gamma)[int(n/2),:]
p0 = (int(n/2), 1)
popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
sigma_x_gamma_px = popt_gauss[1]/2
sigma_x_gamma_um = sigma_x_gamma_px * dX_2 * 1e6

fig, (ax1, ax2) = plt.subplots(1,2, dpi=300)
ax1.imshow(abs(gamma), cmap='jet', extent=((-n/2)*dX_2, (+n/2-1)*dX_2, -n/2*dX_2, (+n/2-1)*dX_2))
ax1.set_title('gamma at pinholes $\sigma = $'+ str(round(sigma_x_gamma_um,1)) + 'um', fontsize = 8)

# propagate to the detector
F_gamma = fftpack.fftshift(fftpack.fftn(fftpack.ifftshift(gamma)))
F_gamma = abs(F_gamma)
F_gamma = F_gamma / np.max(F_gamma)
ax2.imshow(abs(F_gamma), cmap='jet', extent=((-n/2)*dX_1, (+n/2-1)*dX_1, -n/2*dX_1, (+n/2-1)*dX_1))


# determine sigma_F_gamma at the detector
xdata = list(range(n))
ydata = F_gamma[int(n/2),:]
p0 = (int(n/2), 1)
popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
sigma_x_F_gamma_px = popt_gauss[1]/2
sigma_x_F_gamma_um = sigma_x_F_gamma_px *dX_1 * 1e6
ax2.set_title('F_gamma at detector $\sigma = $'+ str(round(sigma_x_F_gamma_um,1)) + 'um', fontsize = 8)

def calc_sigma_F_gamma_um(sigma_gamma_um, n, dX_1, wavelength_nm, create_figure):

  z = 5781 * 1e-3
  z_0 = 1067 * 1e-3
  z_T = z + z_0
  z_eff = z * z_0 / (z_T)
  # dX_1 = 13 * 1e-6

  wavelength = wavelength_nm * 1e-9

  #number of pixels
  # n = partiallycoherent.shape[0]
  # n = 1024
  nx = n
  ny = nx


  # pixel size of the detector dX_1

  dY_1 = dX_1

  # 2D grid and axes at the CCD:
  #x = np.arange(-n/2, n/2, 1) * dX_1
  #y = np.arange(-n/2, n/2, 1) * dX_1
  x = np.arange(-n/2, n/2, 1)
  y = np.arange(-n/2, n/2, 1)
  X1_axis, Y1_axis = np.meshgrid(x*dX_1, y*dX_1, sparse=False)
  #X1_axis, Y1_axis = np.meshgrid(x, y, sparse=False)


  # "pixelsize" at the pinholes:
  dX_2 = wavelength*z/(n*dX_1)
  dY_2 = wavelength*z/(n*dY_1)


  # 2D grid and axes at the double pinholes:
  X2_axis, Y2_axis = np.meshgrid(x*dX_2, y*dY_2, sparse=False)


  #psf = gauss2d(X1_axis,Y1_axis,1.9*13*1e-6)
  #psf = psf / np.max(psf)
  #sigma_F_gamma_um = 24.7



  # abs_gamma = np.abs(gamma)
  # abs_gamma = abs_gamma / np.max(abs_gamma)
  # abs_gamma_list.append(abs_gamma)
  # xdata = list(range(n))
  # ydata = abs_gamma[int(n/2),:]
  # p0 = (int(n/2), 1)
  # popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
  # xi_x_px = popt_gauss[1]/2
  # xi_x_um = xi_x_px * dX_2 * 1e6
  # xi_x_um_list[j] = xi_x_um


  # xdata = list(range(n))
  # ydata = abs_gamma[:,int(n/2)]
  # p0 = (int(n/2), 1)
  # popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
  # xi_y_px = popt_gauss[1]/2
  # xi_y_um = xi_y_px * dX_2 * 1e6
  # xi_y_um_list[j] = xi_y_um

  # sigma_x_F_gamma = sigma_x_F_gamma_um * 1e-6
  # sigma_y_F_gamma = sigma_y_F_gamma_um * 1e-6
  # F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma/dX_1, sigma_y_F_gamma/dX_1)

  # F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma_um*1e-6/dX_1, sigma_y_F_gamma_um*1e-6/dX_1)
  # gamma = fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(F_gamma)))



  # assuming coherence length xi = sigma_gamma at the pinholes
  sigma_x_gamma_um = sigma_gamma_um
  sigma_y_gamma_um = sigma_x_gamma_um



  # gamma at the pinholes
  # gamma = gauss2d(X2_axis, Y2_axis, sigma_x_gamma_um*1e-6, sigma_y_gamma_um*1e-6)
  gamma = gauss2d(X2_axis/dX_2, Y2_axis/dX_2, sigma_x_gamma_um*1e-6/dX_2, sigma_y_gamma_um*1e-6/dX_2)

  xdata = list(range(n))
  ydata = abs(gamma)[int(n/2),:]
  p0 = (int(n/2), 1)
  popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
  sigma_x_gamma_px = popt_gauss[1]/2
  sigma_x_gamma_um = sigma_x_gamma_px * dX_2 * 1e6

  if create_figure == True:
    fig, (ax1, ax2) = plt.subplots(1,2, dpi=300)
    ax1.imshow(abs(gamma), cmap='jet', extent=((-n/2)*dX_2, (+n/2-1)*dX_2, -n/2*dX_2, (+n/2-1)*dX_2))
    ax1.set_title('gamma at pinholes $\sigma = $'+ str(round(sigma_x_gamma_um,1)) + 'um', fontsize = 8)

  # propagate to the detector
  F_gamma = fftpack.fftshift(fftpack.fftn(fftpack.ifftshift(gamma)))
  F_gamma = abs(F_gamma)
  F_gamma = F_gamma / np.max(F_gamma)
  if create_figure == True:
    ax2.imshow(abs(F_gamma), cmap='jet', extent=((-n/2)*dX_1, (+n/2-1)*dX_1, -n/2*dX_1, (+n/2-1)*dX_1))


  # determine sigma_F_gamma at the detector
  xdata = list(range(n))
  ydata = F_gamma[int(n/2),:]
  p0 = (int(n/2), 1)
  popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
  sigma_x_F_gamma_px = popt_gauss[1]/2
  sigma_x_F_gamma_um = sigma_x_F_gamma_px *dX_1 * 1e6
  if create_figure == True:
    ax2.set_title('F_gamma at detector $\sigma = $'+ str(round(sigma_x_F_gamma_um,1)) + 'um', fontsize = 8)
    fig.clf()
    gc.collect()

  return sigma_x_F_gamma_um

dX_1 = 13 * 1e-6
n = 1024

fact_arr = [1.0]
wavelength_nm_arr = [8.0, 13.5, 18.0]

fig, ax1 = plt.subplots(1,1, dpi=300)

for wavelength_nm in wavelength_nm_arr:
  for fact in fact_arr:
    xdata = np.arange(10,700,10)
    ydata = []
    for x in xdata:
      ydata.append(calc_sigma_F_gamma_um(x, int(fact*n), dX_1/fact, wavelength_nm, False))
    ax1.plot(np.log(xdata),np.log(ydata), label=str(wavelength_nm)+'nm')
ax1.set_ylabel('$ln(\sigma$) of FT($\gamma$)')
ax1.set_xlabel('$ln(\sigma$) of $\gamma$')
# ax1.set_ylim([0, 750])
# ax1.set_xlim([0, xdata[-1]])

ax1.legend()

# calc_sigma_F_gamma_um(800)

dX_1 = 13 * 1e-6
n = 1024

fact_arr = [1.0]
wavelength_nm_arr = [8.0, 13.5, 18.0]

fig, ax1 = plt.subplots(1,1, dpi=300)

for wavelength_nm in wavelength_nm_arr:
  for fact in fact_arr:
    xdata = np.arange(10,2000,10)
    ydata = []
    for x in xdata:
      ydata.append(calc_sigma_F_gamma_um(x, int(fact*n), dX_1/fact, wavelength_nm, False))
    ax1.plot(xdata,ydata, label=str(wavelength_nm)+'nm')
ax1.set_ylabel('$\sigma$ of FT($\gamma$)')
ax1.set_xlabel('$\sigma$ of $\gamma$')
ax1.set_xscale('log')
ax1.set_yscale('log')
ax1.grid()
# ax1.set_ylim([0, 750])
# ax1.set_xlim([0, xdata[-1]])

ax1.legend()

# calc_sigma_F_gamma_um(800)

z = 5781 * 1e-3
z_0 = 1067 * 1e-3
z_T = z + z_0
z_eff = z * z_0 / (z_T)
dX_1 = 13 * 1e-6

wavelength = 8 * 1e-9

#number of pixels
# n = partiallycoherent.shape[0]
n = 1024
nx = n
ny = nx


# pixel size of the detector dX_1

dY_1 = dX_1

# 2D grid and axes at the CCD:
#x = np.arange(-n/2, n/2, 1) * dX_1
#y = np.arange(-n/2, n/2, 1) * dX_1
x = np.arange(-n/2, n/2, 1)
y = np.arange(-n/2, n/2, 1)
X1_axis, Y1_axis = np.meshgrid(x*dX_1, y*dX_1, sparse=False)
#X1_axis, Y1_axis = np.meshgrid(x, y, sparse=False)


# "pixelsize" at the pinholes:
dX_2 = wavelength*z/(n*dX_1)
dY_2 = wavelength*z/(n*dY_1)

# 2D grid and axes at the double pinholes:
X2_axis, Y2_axis = np.meshgrid(x*dX_2, y*dY_2, sparse=False)


#psf = gauss2d(X1_axis,Y1_axis,1.9*13*1e-6)
#psf = psf / np.max(psf)
#sigma_F_gamma_um = 24.7



# abs_gamma = np.abs(gamma)
# abs_gamma = abs_gamma / np.max(abs_gamma)
# abs_gamma_list.append(abs_gamma)
# xdata = list(range(n))
# ydata = abs_gamma[int(n/2),:]
# p0 = (int(n/2), 1)
# popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
# xi_x_px = popt_gauss[1]/2
# xi_x_um = xi_x_px * dX_2 * 1e6
# xi_x_um_list[j] = xi_x_um


# xdata = list(range(n))
# ydata = abs_gamma[:,int(n/2)]
# p0 = (int(n/2), 1)
# popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
# xi_y_px = popt_gauss[1]/2
# xi_y_um = xi_y_px * dX_2 * 1e6
# xi_y_um_list[j] = xi_y_um



sigma_x_F_gamma_um = 20
sigma_y_F_gamma_um = sigma_x_F_gamma_um

sigma_x_F_gamma = sigma_x_F_gamma_um * 1e-6
sigma_y_F_gamma = sigma_y_F_gamma_um * 1e-6
# F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma/dX_1, sigma_y_F_gamma/dX_1)

F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma_um*1e-6/dX_1, sigma_y_F_gamma_um*1e-6/dX_1)
# backpropagate to pinholes:
gamma = fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(F_gamma)))



# # assuming coherence length xi = sigma_gamma at the pinholes
# sigma_x_gamma_um = 400
# sigma_y_gamma_um = sigma_x_gamma_um



# gamma at the pinholes
# gamma = gauss2d(X2_axis, Y2_axis, sigma_x_gamma_um*1e-6, sigma_y_gamma_um*1e-6)
# gamma = gauss2d(X2_axis, Y2_axis, sigma_x_gamma_um*1e-6, sigma_y_gamma_um*1e-6)

abs_gamma = np.abs(gamma)
abs_gamma = abs_gamma / np.max(abs_gamma)
xdata = list(range(n))
ydata = abs_gamma[int(n/2),:]
p0 = (int(n/2), 1)
popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
xi_x_px = popt_gauss[1]/2
xi_x_um = xi_x_px * dX_2 * 1e6
sigma_x_gamma_um = xi_x_um


fig, (ax1, ax2) = plt.subplots(1,2, dpi=300)
ax1.imshow(abs(gamma), cmap='jet', extent=((-n/2)*dX_2*1e6, (+n/2-1)*dX_2*1e6, -n/2*dX_2*1e6, (+n/2-1)*dX_2*1e6))
ax1.set_title('gamma at pinholes $\sigma = $'+ str(round(sigma_x_gamma_um,1)) + 'um', fontsize = 8)

# propagate to the detector
# F_gamma = fftpack.fftshift(fftpack.fftn(fftpack.ifftshift(gamma)))
ax2.imshow(abs(F_gamma), cmap='jet', extent=((-n/2)*dX_1*1e6, (+n/2-1)*dX_1*1e6, -n/2*dX_1*1e6, (+n/2-1)*dX_1*1e6))


# determine sigma_F_gamma at the detector
xdata = list(range(n))
ydata = F_gamma[int(n/2),:]
p0 = (int(n/2), 1)
popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
sigma_x_F_gamma_px = popt_gauss[1]/2
sigma_x_F_gamma_um = sigma_x_F_gamma_px * dX_1 * 1e6
ax2.set_title('F_gamma at detector $\sigma = $'+ str(round(sigma_x_F_gamma_um,5)) + 'um', fontsize = 8)



    

# is sigma_F_gamma that is given to the deconvolution algorithm the same as the one that is determined through the deconvolution?????

# how to estimate sigma_F_gamma from the minimum of the profile?
# use a starting guess, equally in x and y
# then iterate around there, find where it becomes negative/positive, find the root
# then iterate y and check whether chi2 distance gets larger or smaller

(xi_um_min, xi_um_max) = (300, 1000)
( calc_sigma_F_gamma_um(xi_um_min, n, dX_1, 8.0, False), calc_sigma_F_gamma_um(xi_um_max, n, dX_1, 8.0, False) )



"""### scan y in a given range and then select minimum"""

# hdf5_file_name_image = hdf5_file_name_image_widget.value
# pixis_avg_width = pixis_avg_width


do_deconvmethod = True
savefigure = False
    #do_deconvmethod = True

#imageid = imageid_widget.value

imageid_excluded = []

if do_deconvmethod == True:

#     imageids_by_energy_hall = get_imageids_with_bgs(beamposition_horizontal_interval)
#     imageids = imageids_by_energy_hall
#     sequence_center = int((len(imageids)-1)/2)

    # quick run:
    #imageids = imageids[sequence_center-5:sequence_center+5]
    # rest of the sequence:
#     imageids = imageids[0:sequence_center-5-1] + imageids[sequence_center+5+1:]
    # manual selection:
#     imageids = [30, 6, 5, 46, 27, 3, 8, 16, 54, 50, 52, 23, 42, 26, 43]

    # df = df0[(df0['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & df0['imageid'].isin(imageids_by_energy_hall)]


    

    count = 0

    from datetime import datetime

    time_taken = 0

    with h5py.File(dph_settings_bgsubtracted_widget.label, 'r') as hdf5_file:
      imageids = hdf5_file['/bgsubtracted/imageid'][:]
    for imageid in [imageids[0]]:
    # for imageid in imageids:
        
#         _lambda_nm_fit = df0[(df0['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & (df0['imageid']==imageid)]['_lambda_nm_fit'].tolist()[0]

        
        hdf5_file_path = dph_settings_bgsubtracted_widget.value
        with h5py.File(hdf5_file_path, 'r') as hdf5_file:
          pixis_image_norm = hdf5_file['/bgsubtracted/pixis_image_norm'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
          pixis_profile_avg = hdf5_file['/bgsubtracted/pixis_profile_avg'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
          timestamp_pulse_id = hdf5_file['Timing/time stamp/fl2user1'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][2]
          pixis_centery_px = hdf5_file['/bgsubtracted/pixis_centery_px'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][0]
          print(pixis_centery_px)

        ph = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['pinholes'].iloc[0]
        separation_um = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['separation_um'].iloc[0]
        orientation = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['orientation'].iloc[0]
        setting_wavelength_nm = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0]
        energy_hall_uJ = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['energy hall'].iloc[0]
        _lambda_nm_fit = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0] # is this stored in df0? get it from profile_fitting?
        
        hdf5_file_name_image = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['hdf5_file_name'].iloc[0]
        pixis_avg_width = 200 # random number, store in hdf5?
        beamposition_horizontal_interval = 1000 # random number, store in hdf5?
        
        

        count = count + 1
        time_left = (len(imageids) + 1 - count) * time_taken

        start = datetime.now()

        z = 5781 * 1e-3
        z_0 = 1067 * 1e-3
        z_T = z + z_0
        z_eff = z * z_0 / (z_T)
        dX_1 = 13 * 1e-6

        print('imageid=' + str(imageid) + ' ' + str(round(count/(len(imageids)+1)*100,2)) +'% ' + str('time left=') + str(time_left)  + ' lambda_nm_fit='+str(_lambda_nm_fit))
        #sigma_F_gamma_um_max = 60
        #partiallycoherent_profile, fullycoherent, fullycoherent_profile, partiallycoherent_rec_profile, partiallycoherent_rec_profile, sigma_F_gamma_um_opt, F_gamma, abs_gamma, xi_um, I_bp, dX_2, cor = deconvmethod(partiallycoherent, z, dX_1, pixis_avg_width, int(pixis_centery_px),_lambda_nm_fit[imageid]*1e-9, sigma_F_gamma_um_max)

        # How to guess these time-savingly???
        sigma_x_F_gamma_um_guess = 14
        sigma_x_F_gamma_um_min = sigma_x_F_gamma_um_guess - 8
        sigma_x_F_gamma_um_max = sigma_x_F_gamma_um_guess + 8
        sigma_x_F_gamma_um_stepsize = 2


        sigma_y_F_gamma_um_guess = 14
        sigma_y_F_gamma_um_min = sigma_y_F_gamma_um_guess - 8
        sigma_y_F_gamma_um_max = sigma_y_F_gamma_um_guess + 8
        sigma_y_F_gamma_um_stepsize = 2

        partiallycoherent = pixis_image_norm
        #pixis_profile_avg_dataset[imageid]
        (
            partiallycoherent_profile,
            fullycoherent_opt_list,
            fullycoherent_profile_opt_list,
            partiallycoherent_rec_list,
            partiallycoherent_rec_profile_list,
            partiallycoherent_rec_profile_min_list,
            delta_rec_min_list,
            delta_profiles_cropped_list,
            sigma_x_F_gamma_um_opt,
            sigma_y_F_gamma_um_list,
            F_gamma_list,
            abs_gamma_list,
            xi_x_um_list,
            xi_y_um_list,
            I_bp,
            dX_2,
            cor_list,
            cor_profiles_list,
            cor_profiles_cropped_list,
            index_opt,
            chi2distance_list,
        ) = deconvmethod(
            partiallycoherent,
            z,
            dX_1,
            pixis_avg_width,
            int(pixis_centery_px),
            _lambda_nm_fit * 1e-9,
            sigma_x_F_gamma_um_min,
            sigma_x_F_gamma_um_max,
            sigma_y_F_gamma_um_min,
            sigma_y_F_gamma_um_max,
            sigma_y_F_gamma_um_stepsize,
            sigma_y_F_gamma_um_stepsize,
            200,
        )

    #                 if delta_profiles_cropped_list[0] < 0 :
    #                     index_opt = np.where(np.asarray(delta_profiles_cropped_list) > 0)[0][0]
    #                 else:
    #                     index_opt = np.where(np.asarray(delta_profiles_cropped_list) < 0)[0][0]

        

        
        # xi_um = xi_x_um_list[index_opt]
        # print('sigma_x_F_gamma_um_opt='+str(sigma_x_F_gamma_um_opt))
        # print('sigma_y_F_gamma_um_list[index_opt]='+str(sigma_y_F_gamma_um_list[index_opt]))
        # print('xi_x_um_list[index_opt]='+str(xi_x_um_list[index_opt]))
        # print('xi_y_um_list[index_opt]='+str(xi_y_um_list[index_opt]))

        # fig, axs = plt.subplots(nrows=7,ncols=1, sharex=True, figsize=(5,15))
        # ax = axs[0]
        # ax.plot(sigma_y_F_gamma_um_list, cor_list)
        # ax.set_ylabel('cor')

        # ax = axs[1]
        # ax.plot(sigma_y_F_gamma_um_list, cor_profiles_list)
        # ax.set_ylabel('cor profiles')

        # ax = axs[2]
        # ax.plot(sigma_y_F_gamma_um_list, chi2distance_list)
        # ax.set_ylabel('chi2distance')
        # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

        # ax = axs[3]
        # ax.plot(sigma_y_F_gamma_um_list, delta_rec_min_list)
        # ax.set_ylabel('delta minimum')

        # ax = axs[4]
        # ax.plot(sigma_y_F_gamma_um_list, delta_profiles_cropped_list)
        # ax.axvline(sigma_y_F_gamma_um_list[index_opt])
        # ax.set_ylabel('delta profiles cropped')

        # ax = axs[5]
        # ax.plot(sigma_y_F_gamma_um_list, xi_x_um_list)
        # ax.set_ylabel('xi_x')
        # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

        # ax = axs[6]
        # ax.plot(sigma_y_F_gamma_um_list, xi_y_um_list)
        # ax.set_ylabel('xi_y')
        # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

        # fig.tight_layout()

    #     if savefigure == True:
    #         savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name
    #         if os.path.isdir(savefigure_dir) == False:
    #             os.mkdir(savefigure_dir)
    #         #savefigure_dir = str(scratch_dir) + '/' + hdf5_file_name_image + '_ph_'+str(ph) + '_d_'+str(separation_um)
    #         savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name + '/' + 'profilewidth_px_' + str(int(pixis_avg_width)) + '_' + 'bg_intervall_um_' + str(int(beamposition_horizontal_interval))
    #         if os.path.isdir(savefigure_dir) == False:
    #             os.mkdir(savefigure_dir)
    #         savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name + '/' + 'profilewidth_px_' + str(int(pixis_avg_width)) + '_' + 'bg_intervall_um_' + str(int(beamposition_horizontal_interval)) + '/profiles_rec2d/'
    #         if os.path.isdir(savefigure_dir) == False:
    #             os.mkdir(savefigure_dir)
    #         plt.savefig(savefigure_dir + '/' + 'yscan_a_' + hdf5_file_name_image \
    #                 + '_ph_'+str(ph) \
    #                 + '_d_'+str(separation_um) \
    #                 + '_E_' + str(format(energy_hall_uJ, '.4f')).zfill(6)  \
    #                 + '_image_'+str(imageid) \
    #                 + '.png', dpi=300, facecolor='w', edgecolor='w',
    #         orientation='portrait', papertype=None, format=None,
    #         transparent=False, bbox_inches=None, pad_inches=0.1,
    #         frameon=None)
    #         plt.savefig(savefigure_dir + '/' + 'yscan_a_' + hdf5_file_name_image \
    #                 + '_ph_'+str(ph) \
    #                 + '_d_'+str(separation_um) \
    #                 + '_E_' + str(format(energy_hall_uJ, '.4f')).zfill(6)  \
    #                 + '_image_'+str(imageid) \
    #                 + '.pdf', dpi=None, facecolor='w', edgecolor='w',
    #         orientation='portrait', papertype=None, format=None,
    #         transparent=False, bbox_inches=None, pad_inches=0.1,
    #         frameon=None)

    #     # fig.clf()
    #     # plt.close()
    #     # gc.collect()


    #     #### only the  profiles
    #     for idx in range(len(fullycoherent_profile_opt_list)):
    #         n = partiallycoherent_profile.shape[0]

    #         xdata = np.linspace((-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3, n)

    #         fig=plt.figure(figsize=(11.69,8.27), dpi= 300, facecolor='w', edgecolor='k')  # A4 sheet in landscape
    #         ax = plt.subplot(1,1,1)
    #         plt.plot(xdata, partiallycoherent_profile, 'b-', label='measured partially coherent', linewidth=1)
    #         plt.plot(xdata, fullycoherent_profile_opt_list[idx], 'r-', label='recovered fully coherent', linewidth=1)
    #         plt.plot(xdata, partiallycoherent_rec_profile_list[idx], 'g-', label='recovered partially coherent', linewidth=1)
    #         #plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
    #         plt.axhline(0, color='k')
    #         plt.xlabel('x / mm', fontsize = 14)
    #         plt.ylabel('Intensity / a.u.', fontsize = 14)
    #         plt.legend()

    #         plt.title('d / $\mu$m = '+str(int(separation_um)) + ' coherence length $\\xi_x$ / $\mu$m = ' + str(round(xi_x_um_list[idx],2)) + ' $\\xi_y$ / $\mu$m = ' + str(round(xi_y_um_list[idx],2)), fontsize=12)

    # #                     props = dict(boxstyle='round', facecolor='wheat', alpha=0.5)
    # #                     textstr = 'corr=' + str(round(cor*100,2)) + '%'
    # #                     ax.text(0.01, 0.99, textstr, transform=ax.transAxes, fontsize=14, verticalalignment='top', bbox=props)

    #         if savefigure == True:
    #             savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name
    #             if os.path.isdir(savefigure_dir) == False:
    #                 os.mkdir(savefigure_dir)
    #             #savefigure_dir = str(scratch_dir) + '/' + hdf5_file_name_image + '_ph_'+str(ph) + '_d_'+str(separation_um)
    #             savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name + '/' + 'profilewidth_px_' + str(int(pixis_avg_width)) + '_' + 'bg_intervall_um_' + str(int(beamposition_horizontal_interval))
    #             if os.path.isdir(savefigure_dir) == False:
    #                 os.mkdir(savefigure_dir)
    #             savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name + '/' + 'profilewidth_px_' + str(int(pixis_avg_width)) + '_' + 'bg_intervall_um_' + str(int(beamposition_horizontal_interval)) + '/profiles_rec2d_scan/'
    #             if os.path.isdir(savefigure_dir) == False:
    #                 os.mkdir(savefigure_dir)
    #             plt.savefig(savefigure_dir + '/' + 'profiles_rec2d_scan_' + hdf5_file_name_image \
    #                     + '_ph_'+str(ph) \
    #                     + '_d_'+str(separation_um) \
    #                     + '_E_' + str(format(energy_hall_uJ, '.4f')).zfill(6)  \
    #                     + '_image_'+str(imageid) \
    #                     + '_sigmay_' +str(sigma_y_F_gamma_um_list[idx]) \
    #                     + '.png', dpi=300, facecolor='w', edgecolor='w',
    #             orientation='portrait', papertype=None, format=None,
    #             transparent=False, bbox_inches=None, pad_inches=0.1,
    #             frameon=None)
    #             plt.savefig(savefigure_dir + '/' + 'profiles_rec2d_scan_' + hdf5_file_name_image \
    #                     + '_ph_'+str(ph) \
    #                     + '_d_'+str(separation_um) \
    #                     + '_E_' + str(format(energy_hall_uJ, '.4f')).zfill(6)  \
    #                     + '_image_'+str(imageid) \
    #                     + '_sigmay_' +str(sigma_y_F_gamma_um_list[idx]) \
    #                     + '.pdf', dpi=None, facecolor='w', edgecolor='w',
    #             orientation='portrait', papertype=None, format=None,
    #             transparent=False, bbox_inches=None, pad_inches=0.1,
    #             frameon=None)

    # #                         pl.dump(fig, file(savefigure_dir + '/' + 'profiles_rec2d_scan_' + hdf5_file_name_image \
    # #                                 + '_ph_'+str(ph) \
    # #                                 + '_d_'+str(separation_um) \
    # #                                 + '_E_' + str(format(energy_hall_uJ, '.4f')).zfill(6)  \
    # #                                 + '_image_'+str(imageid) \
    # #                                 + '_sigmay_' +str(sigma_y_F_gamma_um_list[idx]) \
    # #                                 + '.pickle', 'w'))

    #             fig.clf()
    #             plt.close()
    #             gc.collect()




        # sigma_y_F_gamma_um_min = sigma_y_F_gamma_um_list[index_opt] - 0.5
        # sigma_y_F_gamma_um_max = sigma_y_F_gamma_um_list[index_opt] + 0.5
        # sigma_y_F_gamma_um_stepsize = 0.1

        # partiallycoherent = pixis_image_norm
        # #pixis_profile_avg_dataset[imageid]
        # (
        #     partiallycoherent_profile,
        #     fullycoherent_opt_list,
        #     fullycoherent_profile_opt_list,
        #     partiallycoherent_rec_list,
        #     partiallycoherent_rec_profile_list,
        #     partiallycoherent_rec_profile_min_list,
        #     delta_rec_min_list,
        #     delta_profiles_cropped_list,
        #     sigma_x_F_gamma_um_opt,
        #     sigma_y_F_gamma_um_list,
        #     F_gamma_list,
        #     abs_gamma_list,
        #     xi_x_um_list,
        #     xi_y_um_list,
        #     I_bp,
        #     dX_2,
        #     cor_list,
        #     cor_profiles_list,
        #     cor_profiles_cropped_list,
        #     index_opt,
        #     chi2distance_list,
        # ) = deconvmethod(
        #     partiallycoherent,
        #     z,
        #     dX_1,
        #     pixis_avg_width,
        #     int(pixis_centery_px),
        #     _lambda_nm_fit * 1e-9,
        #     sigma_x_F_gamma_um_min,
        #     sigma_x_F_gamma_um_max,
        #     sigma_y_F_gamma_um_min,
        #     sigma_y_F_gamma_um_max,
        #     sigma_y_F_gamma_um_stepsize,
        #     200,
        # )


        # xi_um = xi_x_um_list[index_opt]
        # xi_x_um = xi_x_um_list[index_opt]
        # xi_y_um = xi_y_um_list[index_opt]

        # print('sigma_x_F_gamma_um_opt='+str(sigma_x_F_gamma_um_opt))
        # print('sigma_y_F_gamma_um_list[index_opt]='+str(sigma_y_F_gamma_um_list[index_opt]))
        # print('xi_x_um_list[index_opt]='+str(xi_x_um_list[index_opt]))
        # print('xi_y_um_list[index_opt]='+str(xi_y_um_list[index_opt]))

        # fig, axs = plt.subplots(nrows=7,ncols=1, sharex=True, figsize=(5,15))
        # ax = axs[0]
        # ax.plot(sigma_y_F_gamma_um_list, cor_list)
        # ax.set_ylabel('cor')

        # ax = axs[1]
        # ax.plot(sigma_y_F_gamma_um_list, cor_profiles_list)
        # ax.set_ylabel('cor profiles')

        # ax = axs[2]
        # ax.plot(sigma_y_F_gamma_um_list, chi2distance_list)
        # ax.set_ylabel('chi2distance')
        # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

        # ax = axs[3]
        # ax.plot(sigma_y_F_gamma_um_list, delta_rec_min_list)
        # ax.set_ylabel('delta minimum')

        # ax = axs[4]
        # ax.plot(sigma_y_F_gamma_um_list, delta_profiles_cropped_list)
        # ax.axvline(sigma_y_F_gamma_um_list[index_opt])
        # ax.set_ylabel('delta profiles cropped')

        # ax = axs[5]
        # ax.plot(sigma_y_F_gamma_um_list, xi_x_um_list)
        # ax.set_ylabel('xi_x')
        # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

        # ax = axs[6]
        # ax.plot(sigma_y_F_gamma_um_list, xi_y_um_list)
        # ax.set_ylabel('xi_y')
        # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

        # fig.tight_layout()


    #     if savefigure == True:
    #         savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name
    #         if os.path.isdir(savefigure_dir) == False:
    #             os.mkdir(savefigure_dir)
    #         #savefigure_dir = str(scratch_dir) + '/' + hdf5_file_name_image + '_ph_'+str(ph) + '_d_'+str(separation_um)
    #         savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name + '/' + 'profilewidth_px_' + str(int(pixis_avg_width)) + '_' + 'bg_intervall_um_' + str(int(beamposition_horizontal_interval))
    #         if os.path.isdir(savefigure_dir) == False:
    #             os.mkdir(savefigure_dir)
    #         savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name + '/' + 'profilewidth_px_' + str(int(pixis_avg_width)) + '_' + 'bg_intervall_um_' + str(int(beamposition_horizontal_interval)) + '/profiles_rec2d/'
    #         if os.path.isdir(savefigure_dir) == False:
    #             os.mkdir(savefigure_dir)
    #         plt.savefig(savefigure_dir + '/' + 'yscan_b_' + hdf5_file_name_image \
    #                 + '_ph_'+str(ph) \
    #                 + '_d_'+str(separation_um) \
    #                 + '_E_' + str(format(energy_hall_uJ, '.4f')).zfill(6)  \
    #                 + '_image_'+str(imageid) \
    #                 + '.png', dpi=300, facecolor='w', edgecolor='w',
    #         orientation='portrait', papertype=None, format=None,
    #         transparent=False, bbox_inches=None, pad_inches=0.1,
    #         frameon=None)
    #         plt.savefig(savefigure_dir + '/' + 'yscan_b_' + hdf5_file_name_image \
    #                 + '_ph_'+str(ph) \
    #                 + '_d_'+str(separation_um) \
    #                 + '_E_' + str(format(energy_hall_uJ, '.4f')).zfill(6)  \
    #                 + '_image_'+str(imageid) \
    #                 + '.pdf', dpi=None, facecolor='w', edgecolor='w',
    #         orientation='portrait', papertype=None, format=None,
    #         transparent=False, bbox_inches=None, pad_inches=0.1,
    #         frameon=None)

    #     fig.clf()
    #     plt.close()
    #     gc.collect()


    #     #df0.loc[(df0['timestamp_pulse_id']==timestamp_pulse_id), 'sigma_F_gamma_um_opt'] = sigma_F_gamma_um_opt
    #     df0.loc[(df0['timestamp_pulse_id']==timestamp_pulse_id), 'xi_um'] = xi_um
    #     df0.loc[(df0['timestamp_pulse_id']==timestamp_pulse_id), 'xi_x_um'] = xi_x_um
    #     df0.loc[(df0['timestamp_pulse_id']==timestamp_pulse_id), 'xi_y_um'] = xi_y_um
    #     # df0.loc[(df0['timestamp_pulse_id']==timestamp_pulse_id), 'pixis_profile_centerx_px_fit'] = pixis_profile_centerx_px_fit[imageid] needed for what?

    #     if imageid == -1:
    #         sigma_F_gamma_um_opt_of_average = sigma_F_gamma_um_opt
    #         xi_um_of_average = xi_um


    #     #A_bp = fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(np.sqrt(partiallycoherent))))  # amplitude
    #     #I_bp = np.abs(A_bp)**2  # intensity


    #     #imagesc(X2_axis*R_1,Y2_axis*R_1,log10(I_bp));


    #     #pixis_yshift_px = int(pixis_centery_px_widget.value)
    #     #p0 = (pixis_yshift_px, 400)
    #     #popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
    #     #pixis_beamwidth_px = popt_gauss[1]

    #     xdata = list(range(n))

    #     fig=plt.figure(figsize=(48, 12), dpi= 80, facecolor='w', edgecolor='k')
    #     plt.subplot(1,4,1)
    #     plt.plot(xdata, partiallycoherent_profile, 'b-', label='measured partially coherent', linewidth=3)
    #     plt.plot(xdata, fullycoherent_profile_opt_list[index_opt], 'r-', label='recovered fully coherent')
    #     plt.plot(xdata, partiallycoherent_rec_profile_list[index_opt], 'g-', label='recovered partially coherent')
    #     #plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
    #     plt.axhline(0, color='k')
    #     plt.legend()

    #     plt.title('coherence length $\\xi$ / $\mu$m = ' + str(round(xi_um,2)))

    #     plt.subplot(1,4,2)
    #     #plt.contourf(x,y,psf,cmap='jet')
    #     #plt.xlim(-5,5)
    #     #plt.ylim(-5,5)
    #     plt.imshow(F_gamma_list[index_opt],cmap='jet', extent=((-n/2)*dX_1, (+n/2-1)*dX_1, -n/2*dX_1, (+n/2-1)*dX_1))
    #     #plt.xlim(-5*dX_1,5*dX_1)
    #     #plt.ylim(-5*dX_1,5*dX_1)
    #     plt.title('$F(\\gamma)$ with $\sigma_x$ = ' + str(round(sigma_x_F_gamma_um_opt,2)) + '$\sigma_y$ = ' + str(round(sigma_y_F_gamma_um_list[index_opt],2)))


    #     plt.subplot(1,4,3)
    #     #plt.xlim(-5,5)
    #     #plt.ylim(-5,5)
    #     #plt.imshow(gamma,cmap='jet', extent=((-n/2)*dX_2, (+n/2-1)*dX_2, -n/2*dX_2, (+n/2-1)*dX_2))
    #     plt.contourf(abs_gamma_list[index_opt],cmap='jet', extent=((-n/2)*dX_2, (+n/2-1)*dX_2, -n/2*dX_2, (+n/2-1)*dX_2))


    #     n = abs_gamma_list[index_opt].shape[0]
    #     xdata = list(range(n))
    #     ydata = abs_gamma_list[index_opt][int(n/2),:]
    #     p0 = (int(n/2), 1)
    #     popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
    #     plt.subplot(1,4,4)
    #     plt.plot(xdata, ydata, 'b-', label='abs(gamma)', linewidth=1)
    #     plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
    #     plt.legend()


    #     if savefigure == True:
    #         #savefigure_dir = str(scratch_dir) + '/' + hdf5_file_name_image + '_ph_'+str(ph) + '_d_'+str(separation_um)
    #         savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name
    #         if os.path.isdir(savefigure_dir) == False:
    #             os.mkdir(savefigure_dir)
    #         savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name + '/' + 'profilewidth_px_' + str(int(pixis_avg_width)) + '_' + 'bg_intervall_um_' + str(int(beamposition_horizontal_interval))
    #         if os.path.isdir(savefigure_dir) == False:
    #             os.mkdir(savefigure_dir)
    #         savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name + '/' + 'profilewidth_px_' + str(int(pixis_avg_width)) + '_' + 'bg_intervall_um_' + str(int(beamposition_horizontal_interval)) + '/deconv_a/'
    #         if os.path.isdir(savefigure_dir) == False:
    #             os.mkdir(savefigure_dir)
    #         plt.savefig(savefigure_dir + '/' + 'deconv_a_' + hdf5_file_name_image \
    #                 + '_ph_'+str(ph) \
    #                 + '_d_'+str(separation_um) \
    #                 + '_E_' + str(format(energy_hall_uJ, '.4f')).zfill(6)  \
    #                 + '_image_'+str(imageid) \
    #                 + '.png', dpi=None, facecolor='w', edgecolor='w',
    #         orientation='portrait', papertype=None, format=None,
    #         transparent=False, bbox_inches=None, pad_inches=0.1,
    #         frameon=None)

    #     fig.clf()
    #     plt.close()
    #     gc.collect()


    #     #### only the  profiles
    #     n = partiallycoherent_profile.shape[0]

    #     xdata = np.linspace((-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3, n)

    #     fig=plt.figure(figsize=(11.69,8.27), dpi= 300, facecolor='w', edgecolor='k')  # A4 sheet in landscape
    #     plt.subplot(1,1,1)
    #     plt.plot(xdata, partiallycoherent_profile, 'b-', label='measured partially coherent', linewidth=3)
    #     plt.plot(xdata, fullycoherent_profile_opt_list[index_opt], 'r-', label='recovered fully coherent', linewidth=1)
    #     #plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
    #     plt.axhline(0, color='k')
    #     plt.xlabel('x / mm', fontsize = 14)
    #     plt.ylabel('Intensity / a.u.', fontsize = 14)
    #     plt.legend()

    #     plt.title('d / $\mu$m = '+str(int(separation_um)) + ' coherence length $\\xi_x$ / $\mu$m = ' + str(round(xi_x_um_list[index_opt],2)) + ' $\\xi_y$ / $\mu$m = ' + str(round(xi_y_um_list[index_opt],2)), fontsize=16)

    #     if savefigure == True:
    #         savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name
    #         if os.path.isdir(savefigure_dir) == False:
    #             os.mkdir(savefigure_dir)
    #         #savefigure_dir = str(scratch_dir) + '/' + hdf5_file_name_image + '_ph_'+str(ph) + '_d_'+str(separation_um)
    #         savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name + '/' + 'profilewidth_px_' + str(int(pixis_avg_width)) + '_' + 'bg_intervall_um_' + str(int(beamposition_horizontal_interval))
    #         if os.path.isdir(savefigure_dir) == False:
    #             os.mkdir(savefigure_dir)
    #         savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name + '/' + 'profilewidth_px_' + str(int(pixis_avg_width)) + '_' + 'bg_intervall_um_' + str(int(beamposition_horizontal_interval)) + '/profiles/'
    #         if os.path.isdir(savefigure_dir) == False:
    #             os.mkdir(savefigure_dir)
    #         plt.savefig(savefigure_dir + '/' + 'profiles_' + hdf5_file_name_image \
    #                 + '_ph_'+str(ph) \
    #                 + '_d_'+str(separation_um) \
    #                 + '_E_' + str(format(energy_hall_uJ, '.4f')).zfill(6)  \
    #                 + '_image_'+str(imageid) \
    #                 + '.png', dpi=300, facecolor='w', edgecolor='w',
    #         orientation='portrait', papertype=None, format=None,
    #         transparent=False, bbox_inches=None, pad_inches=0.1,
    #         frameon=None)
    #         plt.savefig(savefigure_dir + '/' + 'profiles_' + hdf5_file_name_image \
    #                 + '_ph_'+str(ph) \
    #                 + '_d_'+str(separation_um) \
    #                 + '_E_' + str(format(energy_hall_uJ, '.4f')).zfill(6)  \
    #                 + '_image_'+str(imageid) \
    #                 + '.pdf', dpi=None, facecolor='w', edgecolor='w',
    #         orientation='portrait', papertype=None, format=None,
    #         transparent=False, bbox_inches=None, pad_inches=0.1,
    #         frameon=None)

    #     #plt.show()
    #     fig.clf()
    #     plt.close()
    #     gc.collect()




    #                     #### only the  profiles
    #     n = partiallycoherent_profile.shape[0]

    #     xdata = np.linspace((-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3, n)

    #     fig=plt.figure(figsize=(11.69,8.27), dpi= 300, facecolor='w', edgecolor='k')  # A4 sheet in landscape
    #     ax = plt.subplot(1,1,1)
    #     plt.plot(xdata, partiallycoherent_profile, 'b-', label='measured partially coherent', linewidth=1)
    #     plt.plot(xdata, fullycoherent_profile_opt_list[index_opt], 'r-', label='recovered fully coherent', linewidth=1)
    #     plt.plot(xdata, partiallycoherent_rec_profile_list[index_opt], 'g-', label='recovered partially coherent', linewidth=1)
    #     #plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
    #     plt.axhline(0, color='k')
    #     plt.xlabel('x / mm', fontsize = 14)
    #     plt.ylabel('Intensity / a.u.', fontsize = 14)
    #     plt.legend()

    #     plt.title('d / $\mu$m = '+str(int(separation_um)) + ' coherence length $\\xi_x$ / $\mu$m = ' + str(round(xi_x_um_list[index_opt],2)) + ' $\\xi_y$ / $\mu$m = ' + str(round(xi_y_um_list[index_opt],2)), fontsize=16)

    #     #props = dict(boxstyle='round', facecolor='wheat', alpha=0.5)
    #     #textstr = 'corr=' + str(round(cor*100,2)) + '%'
    #     #ax.text(0.01, 0.99, textstr, transform=ax.transAxes, fontsize=14, verticalalignment='top', bbox=props)

    #     if savefigure == True:
    #         savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name
    #         if os.path.isdir(savefigure_dir) == False:
    #             os.mkdir(savefigure_dir)
    #         #savefigure_dir = str(scratch_dir) + '/' + hdf5_file_name_image + '_ph_'+str(ph) + '_d_'+str(separation_um)
    #         savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name + '/' + 'profilewidth_px_' + str(int(pixis_avg_width)) + '_' + 'bg_intervall_um_' + str(int(beamposition_horizontal_interval))
    #         if os.path.isdir(savefigure_dir) == False:
    #             os.mkdir(savefigure_dir)
    #         savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name + '/' + 'profilewidth_px_' + str(int(pixis_avg_width)) + '_' + 'bg_intervall_um_' + str(int(beamposition_horizontal_interval)) + '/profiles_rec2d/'
    #         if os.path.isdir(savefigure_dir) == False:
    #             os.mkdir(savefigure_dir)
    #         plt.savefig(savefigure_dir + '/' + 'profiles_rec2d_' + hdf5_file_name_image \
    #                 + '_ph_'+str(ph) \
    #                 + '_d_'+str(separation_um) \
    #                 + '_E_' + str(format(energy_hall_uJ, '.4f')).zfill(6)  \
    #                 + '_image_'+str(imageid) \
    #                 + '.png', dpi=300, facecolor='w', edgecolor='w',
    #         orientation='portrait', papertype=None, format=None,
    #         transparent=False, bbox_inches=None, pad_inches=0.1,
    #         frameon=None)
    #         plt.savefig(savefigure_dir + '/' + 'profiles_rec2d_' + hdf5_file_name_image \
    #                 + '_ph_'+str(ph) \
    #                 + '_d_'+str(separation_um) \
    #                 + '_E_' + str(format(energy_hall_uJ, '.4f')).zfill(6)  \
    #                 + '_image_'+str(imageid) \
    #                 + '.pdf', dpi=None, facecolor='w', edgecolor='w',
    #         orientation='portrait', papertype=None, format=None,
    #         transparent=False, bbox_inches=None, pad_inches=0.1,
    #         frameon=None)

    # #     plt.show()
    #     fig.clf()
    #     plt.close()
        # gc.collect()


        # fig=plt.figure(figsize=(36, 16), dpi= 80, facecolor='w', edgecolor='k')
        # plt.subplot(1,3,1)
        # plt.imshow(partiallycoherent,origin='lower', interpolation='nearest', aspect=1, cmap='jet', vmin=0, vmax=1)
        # plt.subplot(1,3,2)
        # plt.imshow(fullycoherent_opt_list[index_opt],origin='lower', interpolation='nearest', aspect=1, cmap='jet', vmin=0, vmax=1)

        # plt.subplot(1,3,3)
        #plt.xlim(-5,5)
        #plt.ylim(-5,5)
        #plt.imshow(gamma,cmap='jet', extent=((-n/2)*dX_2, (+n/2-1)*dX_2, -n/2*dX_2, (+n/2-1)*dX_2))
        # n = partiallycoherent.shape[0]
        # #plt.imshow(np.log10(I_bp),cmap='jet', extent=((-n/2)*dX_2, (+n/2-1)*dX_2, -n/2*dX_2, (+n/2-1)*dX_2))
        # plt.imshow(np.log10(I_bp),cmap='jet')

        # if savefigure == True:
        #     savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name
        #     if os.path.isdir(savefigure_dir) == False:
        #         os.mkdir(savefigure_dir)
        #     #savefigure_dir = str(scratch_dir) + '/' + hdf5_file_name_image + '_ph_'+str(ph) + '_d_'+str(separation_um)
        #     savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name + '/' + 'profilewidth_px_' + str(int(pixis_avg_width)) + '_' + 'bg_intervall_um_' + str(int(beamposition_horizontal_interval))
        #     if os.path.isdir(savefigure_dir) == False:
        #         os.mkdir(savefigure_dir)
        #     savefigure_dir = str(scratch_dir) + '/' + dph_settings_bgsubtracted_widget.value.name + '/' + 'profilewidth_px_' + str(int(pixis_avg_width)) + '_' + 'bg_intervall_um_' + str(int(beamposition_horizontal_interval)) + '/deconv_b/'
        #     if os.path.isdir(savefigure_dir) == False:
        #         os.mkdir(savefigure_dir)
        #     plt.savefig(savefigure_dir + '/' + 'deconv_b_' + hdf5_file_name_image \
        #             + '_ph_'+str(ph) \
        #             + '_d_'+str(separation_um) \
        #             + '_E_' + str(format(energy_hall_uJ, '.4f')).zfill(6)  \
        #             + '_image_'+str(imageid) \
        #             + '.png', dpi=None, facecolor='w', edgecolor='w',
        #     orientation='portrait', papertype=None, format=None,
        #     transparent=False, bbox_inches=None, pad_inches=0.1,
        #     frameon=None)
        # fig.clf()
        # plt.close()
        # gc.collect()


        end = datetime.now()
        time_taken = end - start
        print(time_taken)

        # clear_output()


        # xi_x_um_mean = df0[(df0['hdf5_file_name'] == hdf5_file_name_image) & (df0['pinholes'] == ph) & (~df0['imageid'].isin(imageid_excluded))]['xi_x_um'].mean(skipna=True)
        # xi_x_um_std = df0[(df0['hdf5_file_name'] == hdf5_file_name_image) & (df0['pinholes'] == ph) & (~df0['imageid'].isin(imageid_excluded))]['xi_x_um'].std(skipna=True)
        # print('xi_x_um = ' + str(xi_x_um_mean) + ' +/- ' + str(xi_x_um_std))

        # xi_y_um_mean = df0[(df0['hdf5_file_name'] == hdf5_file_name_image) & (df0['pinholes'] == ph) & (~df0['imageid'].isin(imageid_excluded))]['xi_y_um'].mean(skipna=True)
        # xi_y_um_std = df0[(df0['hdf5_file_name'] == hdf5_file_name_image) & (df0['pinholes'] == ph) & (~df0['imageid'].isin(imageid_excluded))]['xi_y_um'].std(skipna=True)
        # print('xi_y_um = ' + str(xi_y_um_mean) + ' +/- ' + str(xi_y_um_std))



        gc.collect()

display(Javascript('''google.colab.output.setIframeHeight(0, true, {maxHeight: 5000})''')) # https://stackoverflow.com/a/57346765

( xi_x_um_list[index_opt] , xi_y_um_list[index_opt] )

"""### Only scan the radius"""

def deconvmethod_1d(partiallycoherent, z, dX_1, profilewidth, pixis_centery_px, wavelength, sigma_F_gamma_um_min, sigma_F_gamma_um_max, sigma_F_gamma_um_stepsize, crop_px):

    
    #number of pixels
    n = partiallycoherent.shape[0]
    nx = n
    ny = nx


    # pixel size of the detector dX_1
    
    dY_1 = dX_1

    # 2D grid and axes at the CCD:
    #x = np.arange(-n/2, n/2, 1) * dX_1
    #y = np.arange(-n/2, n/2, 1) * dX_1
    x = np.arange(-n/2, n/2, 1)
    y = np.arange(-n/2, n/2, 1)
    X1_axis, Y1_axis = np.meshgrid(x*dX_1, y*dX_1, sparse=False)
    #X1_axis, Y1_axis = np.meshgrid(x, y, sparse=False)


    # "pixelsize" at the pinholes:
    dX_2 = wavelength*z/(n*dX_1)
    dY_2 = wavelength*z/(n*dY_1)

    # 2D grid and axes at the double pinholes:
    X2_axis, Y2_axis = np.meshgrid(x*dX_2, y*dY_2, sparse=False)


    
    #psf = gauss2d(X1_axis,Y1_axis,1.9*13*1e-6)
    #psf = psf / np.max(psf)
    #sigma_F_gamma_um = 24.7
    
    
    sigma_F_gamma_um_list = np.arange(sigma_F_gamma_um_min,sigma_F_gamma_um_max,sigma_F_gamma_um_stepsize)
    listlength = len(sigma_F_gamma_um_list)
    xi_um_list = np.array(listlength * [np.nan])
    
    
    
    cor_list = np.array(listlength * [np.nan])
    cor_profiles_list = np.array(listlength * [np.nan])
    
    fullycoherent_profile_min_opt_list = np.array(listlength * [np.nan])
    fullycoherent_profile_opt_list = []
    fullycoherent_opt_list = []
    partiallycoherent_rec_list = []
    partiallycoherent_rec_profile_list = []
    partiallycoherent_rec_profile_min_list = np.array(listlength * [np.nan])
    delta_rec_min_list = np.array(listlength * [np.nan])
    delta_profiles_cropped_list = np.array(listlength * [np.nan])
    chi2distance_list = np.array(listlength * [np.nan])
    
    F_gamma_list = []
    gamma_list = []
    abs_gamma_list = []
    
    crop_px = 200
    

    
    fig = plt.figure(constrained_layout=False, figsize=(10,6), dpi=300)

    gs = gridspec.GridSpec(8, 3, figure=fig)

    ax00 = fig.add_subplot(gs[0, 0])
    ax10 = fig.add_subplot(gs[1, 0])
    ax20 = fig.add_subplot(gs[2, 0])
    ax30 = fig.add_subplot(gs[3, 0])
    ax40 = fig.add_subplot(gs[4, 0])
    ax50 = fig.add_subplot(gs[5, 0])
    ax60 = fig.add_subplot(gs[6, 0])
    ax70 = fig.add_subplot(gs[7, 0])

    ax = fig.add_subplot(gs[:, 1:])
    
    
    
    # ax = axs[0]
    # ax.plot(sigma_y_F_gamma_um_list, cor_list)
    # ax.set_ylabel('cor')

    # ax = axs[1]
    # ax.plot(sigma_y_F_gamma_um_list, cor_profiles_list)
    # ax.set_ylabel('cor profiles')

    # ax = axs[2]
    # ax.plot(sigma_y_F_gamma_um_list, chi2distance_list)
    # ax.set_ylabel('chi2distance')
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

    # ax = axs[3]
    # ax.plot(sigma_y_F_gamma_um_list, delta_rec_min_list)
    # ax.set_ylabel('delta minimum')

    # ax = axs[4]
    # ax.plot(sigma_y_F_gamma_um_list, delta_profiles_cropped_list)
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])
    # ax.set_ylabel('delta profiles cropped')

    # ax = axs[5]
    # ax.plot(sigma_y_F_gamma_um_list, xi_x_um_list)
    # ax.set_ylabel('xi_x')
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

    # ax = axs[6]
    # ax.plot(sigma_y_F_gamma_um_list, xi_y_um_list)
    # ax.set_ylabel('xi_y')
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

    # fig.tight_layout()
    # plt.xlim([sigma_y_F_gamma_um_list[0], sigma_y_F_gamma_um_list[-1]])
    # plt.show()

    z = 5781 * 1e-3
    z_0 = 1067 * 1e-3
    z_T = z + z_0
    z_eff = z * z_0 / (z_T)
    dX_1 = 13 * 1e-6

    j = 0
    index_opt = 0
    # for sigma_F_gamma_um in sigma_F_gamma_um_list:
    sigma_F_gamma_um_list = np.arange(sigma_F_gamma_um_min,sigma_F_gamma_um_max,sigma_F_gamma_um_stepsize)
    sigma_F_gamma_um_list_length = len(sigma_F_gamma_um_list)
    fullycoherent_profile_min_list = np.array(sigma_F_gamma_um_list_length * [np.nan])
    i = 0


    partiallycoherent_profile = np.mean(partiallycoherent[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
    partiallycoherent_profile = normalize(partiallycoherent_profile)

    # see https://stackoverflow.com/a/52672859
    # fig, axs = plt.subplots(nrows=1,ncols=1, sharex=True, figsize=(5,5))
    # ax = axs
    # ax.set_ylabel('fully coherent profile min')
    # fig.tight_layout()
    
    

    ax00.cla()
    ax10.cla()
    ax20.cla()
    ax30.cla()
    ax40.cla()
    ax50.cla()
    ax60.cla()
    ax70.cla()
    
    ax00.plot(sigma_F_gamma_um_list, cor_list)
    ax00.set_ylabel('cor')
    ax20.axvline(sigma_F_gamma_um_list[index_opt])
    ax00.set_xlim([sigma_F_gamma_um_list[0], sigma_F_gamma_um_list[-1]])

    
    ax10.plot(sigma_F_gamma_um_list, cor_profiles_list)
    ax10.set_ylabel('cor profiles')
    ax20.axvline(sigma_F_gamma_um_list[index_opt])
    ax10.set_xlim([sigma_F_gamma_um_list[0], sigma_F_gamma_um_list[-1]])

    
    ax20.plot(sigma_F_gamma_um_list, chi2distance_list)
    ax20.set_ylabel('chi2distance')
    ax20.axvline(sigma_F_gamma_um_list[index_opt])
    ax20.set_xlim([sigma_F_gamma_um_list[0], sigma_F_gamma_um_list[-1]])

    
    ax30.plot(sigma_F_gamma_um_list, delta_rec_min_list)
    ax30.set_ylabel('delta minimum')
    ax30.set_xlim([sigma_F_gamma_um_list[0], sigma_F_gamma_um_list[-1]])

    
    ax40.plot(sigma_F_gamma_um_list, delta_profiles_cropped_list)
    ax40.axvline(sigma_F_gamma_um_list[index_opt])
    ax40.set_ylabel('delta profiles cropped')
    ax40.set_xlim([sigma_F_gamma_um_list[0], sigma_F_gamma_um_list[-1]])

    
    ax50.plot(sigma_F_gamma_um_list, xi_um_list)
    ax50.set_ylabel('xi')
    ax50.axvline(sigma_F_gamma_um_list[index_opt])
    ax50.set_xlim([sigma_F_gamma_um_list[0], sigma_F_gamma_um_list[-1]])

    
    

    for sigma_F_gamma_um in sigma_F_gamma_um_list:

      sigma_F_gamma = sigma_F_gamma_um * 1e-6
      
      F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_F_gamma/dX_1, sigma_F_gamma/dX_1)
      #psf = gauss2d(X1_axis,Y1_axis,1.9)

      # Restore Image using Richardson-Lucy algorithm
      #fullycoherent = restoration.richardson_lucy(partiallycoherent, psf, 5)
      fullycoherent = restoration.wiener(partiallycoherent, F_gamma, 1)
      #fullycoherent = np.real(deconvolve(partiallycoherent, psf))

      fullycoherent = fullycoherent / np.max(fullycoherent[200:-200,200:-200])
      fullycoherent_profile = np.mean(fullycoherent[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
      fullycoherent_profile = fullycoherent_profile / np.max(fullycoherent_profile[200:-200]) # ignore what happens on the edges

      fullycoherent_profile_min = np.min(fullycoherent_profile[200:-200]) # ignore what happens on the edges
      fullycoherent_profile_min_list[i] = fullycoherent_profile_min
      
      
      ax70.cla()
      ax70.plot(sigma_F_gamma_um_list, fullycoherent_profile_min_list)
      ax70.set_xlim([sigma_F_gamma_um_list[0], sigma_F_gamma_um_list[-1]])
      ax70.set_ylim([-0.1*np.min(partiallycoherent_profile[200:-200]), np.min(partiallycoherent_profile[200:-200])])
      ax70.axhline(0, color='k')
      # plt.title('sigma_x_F_gamma=' + str(sigma_x_F_gamma_um) + ' sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min))


      n = partiallycoherent_profile.shape[0]
      xdata = np.linspace((-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3, n)

      ax.cla()
      ax.plot(xdata, partiallycoherent_profile, 'b-', label='measured partially coherent', linewidth=1)
      ax.plot(xdata, fullycoherent_profile, 'r-', label='recovered fully coherent', linewidth=1)
      # ax.plot(xdata, partiallycoherent_rec_profile_list[index_opt], 'g-', label='recovered partially coherent', linewidth=1)
      #plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
      ax.axhline(0, color='k')
      ax.set_xlabel('x / mm', fontsize = 8)
      ax.set_ylabel('Intensity / a.u.', fontsize = 8)
      ax.set_xlim([xdata[0], xdata[-1]])
      # plt.legend()

      # plt.title('d / $\mu$m = '+str(int(separation_um)) + ' coherence length $\\xi_x$ / $\mu$m = ' + str(round(xi_x_um_list[index_opt],2)) + ' $\\xi_y$ / $\mu$m = ' + str(round(xi_y_um_list[index_opt],2)), fontsize=16)




      # see https://stackoverflow.com/a/29675706
      display(plt.gcf())
      clear_output(wait=True)
      # plt.show()

      if fullycoherent_profile_min<0:
        break
      else:
        i = i + 1

    
            


    # sigma_x_F_gamma_um_opt = sigma_x_F_gamma_um_list[i-1]
    xdata = sigma_F_gamma_um_list[0:i+1] # why i+1? should be i?
    ydata = fullycoherent_profile_min_list[0:i+1]
    def func(x, a, b, c):
      return a*x**2 + b*x + c
    popt_func, pcov_func = curve_fit(func, xdata, ydata)
    a = popt_func[0]
    b = popt_func[1]
    c = popt_func[2]
    
    sigma_F_gamma_um_opt = brenth(func, xdata[0], xdata[-1], args=(a,b,c))
    
    ax70.plot(sigma_F_gamma_um_list, func(sigma_F_gamma_um_list, a, b, c))
    ax70.axvline(sigma_F_gamma_um_opt)
    
    display(plt.gcf())
    clear_output(wait=True)
    # input("Press Enter to continue...")

    sigma_F_gamma = sigma_F_gamma_um_opt * 1e-6
    
    F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_F_gamma/dX_1, sigma_F_gamma/dX_1)
    #psf = gauss2d(X1_axis,Y1_axis,1.9)

    # Restore Image using Richardson-Lucy algorithm
    #fullycoherent = restoration.richardson_lucy(partiallycoherent, psf, 5)
    fullycoherent_opt = restoration.wiener(partiallycoherent, F_gamma, 1)
    #fullycoherent = np.real(deconvolve(partiallycoherent, psf))



    fullycoherent_opt = fullycoherent_opt / np.max(fullycoherent_opt[200:-200,200:-200])

    
    fullycoherent_profile_opt = np.mean(fullycoherent_opt[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
    #fullycoherent_profile = normalize(fullycoherent_profile)
    fullycoherent_profile_opt = fullycoherent_profile_opt / np.max(fullycoherent_profile_opt[200:-200]) # ignore what happens on the edges

    fullycoherent_profile_min_opt = np.min(fullycoherent_profile_opt[200:-200]) # ignore what happens on the edges
    



    # # fine-tuning in stepsize of 0.1

    # sigma_x_F_gamma_um_list = np.arange(sigma_x_F_gamma_um_opt,sigma_x_F_gamma_um_opt+1,0.05)
    # sigma_x_F_gamma_um_list_length = len(sigma_x_F_gamma_um_list)
    # fullycoherent_profile_min_list = np.array(sigma_x_F_gamma_um_list_length * [np.nan])
    # fullycoherent_list = []
    # fullycoherent_profile_list = []
    
    # i = 0
    # # fig, axs = plt.subplots(nrows=1,ncols=1, sharex=True, figsize=(5,5))
    # # ax = axs
    # for sigma_x_F_gamma_um in sigma_x_F_gamma_um_list:

    #     sigma_x_F_gamma = sigma_x_F_gamma_um * 1e-6
    #     sigma_y_F_gamma = sigma_y_F_gamma_um * 1e-6
    #     F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma/dX_1, sigma_y_F_gamma/dX_1)
    #     #psf = gauss2d(X1_axis,Y1_axis,1.9)

    #     # Restore Image using Richardson-Lucy algorithm
    #     #fullycoherent = restoration.richardson_lucy(partiallycoherent, psf, 5)
    #     fullycoherent = restoration.wiener(partiallycoherent, F_gamma, 1)
    #     #fullycoherent = np.real(deconvolve(partiallycoherent, psf))



    #     fullycoherent = fullycoherent / np.max(fullycoherent[200:-200,200:-200])
    #     fullycoherent_list.append(fullycoherent)
        

    #     fullycoherent_profile = np.mean(fullycoherent[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
    #     #fullycoherent_profile = normalize(fullycoherent_profile)
    #     fullycoherent_profile = fullycoherent_profile / np.max(fullycoherent_profile[200:-200]) # ignore what happens on the edges
    #     fullycoherent_profile_list.append(fullycoherent_profile)

    #     fullycoherent_profile_min = np.min(fullycoherent_profile[200:-200]) # ignore what happens on the edges
    #     fullycoherent_profile_min_list[i] = fullycoherent_profile_min

    #     # print('sigma_x_F_gamma=' + str(sigma_x_F_gamma_um) + ' sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min))

    #     # clear_output(wait=True)
    #     # plt.plot(sigma_x_F_gamma_um_list, fullycoherent_profile_min_list)
    #     # ax.set_ylabel('fully coherent profile min')
    #     # plt.xlim([sigma_x_F_gamma_um_list[0], sigma_x_F_gamma_um_list[-1]])
    #     # plt.ylim([0, np.min(partiallycoherent_profile[200:-200])])
    #     # # plt.title('sigma_x_F_gamma=' + str(sigma_x_F_gamma_um) + ' sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min))
    #     # plt.show()


    #     ax70.cla()
    #     ax70.plot(sigma_x_F_gamma_um_list, fullycoherent_profile_min_list)
    #     ax70.set_xlim([sigma_x_F_gamma_um_list[0], sigma_x_F_gamma_um_list[-1]])
    #     ax70.set_ylim([-0.1*np.min(partiallycoherent_profile[200:-200]), np.min(partiallycoherent_profile[200:-200])])
    #     ax70.axhline(0, color='k')
    #     # plt.title('sigma_x_F_gamma=' + str(sigma_x_F_gamma_um) + ' sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min))






    #     n = partiallycoherent_profile.shape[0]
    #     xdata = np.linspace((-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3, n)

    #     ax.cla()
    #     ax.plot(xdata, partiallycoherent_profile, 'b-', label='measured partially coherent', linewidth=1)
    #     ax.plot(xdata, fullycoherent_profile, 'r-', label='recovered fully coherent', linewidth=1)
    #     # ax.plot(xdata, partiallycoherent_rec_profile_list[index_opt], 'g-', label='recovered partially coherent', linewidth=1)
    #     #plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
    #     ax.axhline(0, color='k')
    #     ax.set_xlabel('x / mm', fontsize = 8)
    #     ax.set_ylabel('Intensity / a.u.', fontsize = 8)
    #     ax.set_xlim([xdata[0], xdata[-1]])
    #     # plt.legend()

    #     # plt.title('d / $\mu$m = '+str(int(separation_um)) + ' coherence length $\\xi_x$ / $\mu$m = ' + str(round(xi_x_um_list[index_opt],2)) + ' $\\xi_y$ / $\mu$m = ' + str(round(xi_y_um_list[index_opt],2)), fontsize=16)




    #     # see https://stackoverflow.com/a/29675706
    #     display(plt.gcf())
    #     clear_output(wait=True)
    #     # plt.show()



    #     if fullycoherent_profile_min<0:
    #         break
    #     i = i + 1
    # sigma_x_F_gamma_um_opt = sigma_x_F_gamma_um_list[i-1]
    # fullycoherent_opt = fullycoherent_list[i-1]
    fullycoherent_opt_list.append(fullycoherent_opt)
    # fullycoherent_profile_opt = fullycoherent_profile_list[i-1]
    fullycoherent_profile_opt_list.append(fullycoherent_profile_opt)
    # fullycoherent_profile_min_opt = fullycoherent_profile_min_list[i-1]
    fullycoherent_profile_min_opt_list[j] = fullycoherent_profile_min_opt
    
    F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_F_gamma_um_opt*1e-6/dX_1, sigma_F_gamma_um*1e-6/dX_1)
    F_gamma_list.append(F_gamma)
    gamma = fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(F_gamma)))
    gamma_list.append(gamma)

    partiallycoherent_rec = np.abs(convolve(fullycoherent_opt,F_gamma))
    partiallycoherent_rec = normalize(partiallycoherent_rec)
    partiallycoherent_rec_list.append(partiallycoherent_rec)
    partiallycoherent_rec_profile = np.mean(partiallycoherent_rec[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
    partiallycoherent_rec_profile = normalize(partiallycoherent_rec_profile)
    partiallycoherent_rec_profile_list.append(partiallycoherent_rec_profile)
    partiallycoherent_rec_profile_min_list[j] = np.min(partiallycoherent_rec_profile)
    #partiallycoherent_rec_profile = partiallycoherent_rec_profile / partiallycoherent_rec_profile[np.where(partiallycoherent_profile == 1.0)[0][0]]
    cor = corr2(partiallycoherent, partiallycoherent_rec)
    cor_profiles = corr2(partiallycoherent_profile, partiallycoherent_rec_profile)
    cor_list[j] = corr2(partiallycoherent, partiallycoherent_rec)
    cor_profiles_list[j] = cor_profiles
    #sigma_y_F_gamma_um_opt = sigma_y_F_gamma_um

    xdata = np.linspace((-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3, n)
    ax.cla()
    ax.plot(xdata, partiallycoherent_profile, 'b-', label='measured partially coherent', linewidth=1)
    ax.plot(xdata, fullycoherent_profile_opt, 'r-', label='recovered fully coherent', linewidth=1)
    ax.plot(xdata, partiallycoherent_rec_profile_list[index_opt], 'g-', label='recovered partially coherent', linewidth=1)
    #plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
    ax.axhline(0, color='k')
    ax.set_xlabel('x / mm', fontsize = 8)
    ax.set_ylabel('Intensity / a.u.', fontsize = 8)
    ax.set_xlim([xdata[0], xdata[-1]])
    
    
    delta_profiles_cropped_list[j] = np.sum(partiallycoherent_profile[crop_px:-crop_px] - partiallycoherent_rec_profile[crop_px:-crop_px])
    
    
#         print('sigma_x_F_gamma_opt=' + str(sigma_x_F_gamma_um_opt) + 'sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min_list[i-1]) + '\\' + ' correlation partiallycohernet measurement and reconstruction = ' + str(round(cor*100,2)) + '%')


    # determine chi2 distance
    number_of_bins = 100
    hist1, bin_edges1 = np.histogram(partiallycoherent.ravel(), bins=np.linspace(0,1,number_of_bins))
    hist2, bin_edges2 = np.histogram(partiallycoherent_rec.ravel(), bins=np.linspace(0,1,number_of_bins))
    chi2distance_list[j] = chi2_distance(hist1, hist2)

    index_opt = np.where(chi2distance_list == np.nanmin(chi2distance_list))[0][0]


    # determine difference of miniumum of measured and reconstructed profile
    delta_rec_min_list[j] = np.min(partiallycoherent_rec_profile) - np.min(partiallycoherent_profile)

    

    xdata = list(range(n))
    ydata = fullycoherent[pixis_centery_px,:]
    ydata = ydata / np.max(ydata)
    

    
    abs_gamma = np.abs(gamma)
    abs_gamma = abs_gamma / np.max(abs_gamma)
    abs_gamma_list.append(abs_gamma)
    xdata = list(range(n))
    ydata = abs_gamma[int(n/2),:]
    p0 = (int(n/2), 1)
    popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
    xi_px = popt_gauss[1]/2
    xi_um = xi_px * dX_2 * 1e6
    xi_um_list[j] = xi_um
    
    
    # xdata = list(range(n))
    # ydata = abs_gamma[:,int(n/2)]
    # p0 = (int(n/2), 1)
    # popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
    # xi_px = popt_gauss[1]/2
    # xi_um = xi_y_px * dX_2 * 1e6
    # xi_um_list[j] = xi_um
    
    #print('coherence length xi/um = ' + str(xi_um))


        
        
    
    # index_opt = np.where( np.abs(partiallycoherent_rec_profile_min_list - np.min(partiallycoherent_profile)) == np.min(np.abs(partiallycoherent_rec_profile_min_list - np.min(partiallycoherent_profile)) ) )[0][0]
    
        
    A_bp = fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(np.sqrt(partiallycoherent))))  # amplitude
    I_bp = np.abs(A_bp)**2  # intensity
    
    return (partiallycoherent_profile, fullycoherent_opt_list, fullycoherent_profile_opt_list,  partiallycoherent_rec_list, partiallycoherent_rec_profile_list, partiallycoherent_rec_profile_min_list, delta_rec_min_list, delta_profiles_cropped_list, sigma_F_gamma_um_opt, sigma_F_gamma_um_list, F_gamma_list, abs_gamma_list, xi_um_list, I_bp, dX_2, cor_list, cor_profiles_list, cor_profiles_list, index_opt, chi2distance_list)

# hdf5_file_name_image = hdf5_file_name_image_widget.value
# pixis_avg_width = pixis_avg_width


do_deconvmethod = True
savefigure = False
    #do_deconvmethod = True

#imageid = imageid_widget.value

imageid_excluded = []

if do_deconvmethod == True:

#     imageids_by_energy_hall = get_imageids_with_bgs(beamposition_horizontal_interval)
#     imageids = imageids_by_energy_hall
#     sequence_center = int((len(imageids)-1)/2)

    # quick run:
    #imageids = imageids[sequence_center-5:sequence_center+5]
    # rest of the sequence:
#     imageids = imageids[0:sequence_center-5-1] + imageids[sequence_center+5+1:]
    # manual selection:
#     imageids = [30, 6, 5, 46, 27, 3, 8, 16, 54, 50, 52, 23, 42, 26, 43]

    # df = df0[(df0['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & df0['imageid'].isin(imageids_by_energy_hall)]


    

    count = 0

    from datetime import datetime

    time_taken = 0

    with h5py.File(dph_settings_bgsubtracted_widget.label, 'r') as hdf5_file:
      imageids = hdf5_file['/bgsubtracted/imageid'][:]
    for imageid in [imageids[0]]:
    # for imageid in imageids:
        
#         _lambda_nm_fit = df0[(df0['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & (df0['imageid']==imageid)]['_lambda_nm_fit'].tolist()[0]

        
        hdf5_file_path = dph_settings_bgsubtracted_widget.value
        with h5py.File(hdf5_file_path, 'r') as hdf5_file:
          pixis_image_norm = hdf5_file['/bgsubtracted/pixis_image_norm'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
          pixis_profile_avg = hdf5_file['/bgsubtracted/pixis_profile_avg'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
          timestamp_pulse_id = hdf5_file['Timing/time stamp/fl2user1'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][2]
          pixis_centery_px = hdf5_file['/bgsubtracted/pixis_centery_px'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][0]
          print(pixis_centery_px)

        ph = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['pinholes'].iloc[0]
        separation_um = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['separation_um'].iloc[0]
        orientation = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['orientation'].iloc[0]
        setting_wavelength_nm = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0]
        energy_hall_uJ = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['energy hall'].iloc[0]
        _lambda_nm_fit = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0] # is this stored in df0? get it from profile_fitting?
        
        hdf5_file_name_image = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['hdf5_file_name'].iloc[0]
        pixis_avg_width = 200 # random number, store in hdf5?
        beamposition_horizontal_interval = 1000 # random number, store in hdf5?
        
        

        count = count + 1
        time_left = (len(imageids) + 1 - count) * time_taken

        start = datetime.now()

        z = 5781 * 1e-3
        z_0 = 1067 * 1e-3
        z_T = z + z_0
        z_eff = z * z_0 / (z_T)
        dX_1 = 13 * 1e-6

        print('imageid=' + str(imageid) + ' ' + str(round(count/(len(imageids)+1)*100,2)) +'% ' + str('time left=') + str(time_left)  + ' lambda_nm_fit='+str(_lambda_nm_fit))
        #sigma_F_gamma_um_max = 60
        #partiallycoherent_profile, fullycoherent, fullycoherent_profile, partiallycoherent_rec_profile, partiallycoherent_rec_profile, sigma_F_gamma_um_opt, F_gamma, abs_gamma, xi_um, I_bp, dX_2, cor = deconvmethod(partiallycoherent, z, dX_1, pixis_avg_width, int(pixis_centery_px),_lambda_nm_fit[imageid]*1e-9, sigma_F_gamma_um_max)

        # How to guess these time-savingly???
        sigma_F_gamma_um_min = 5
        sigma_F_gamma_um_max = 30
        sigma_F_gamma_um_stepsize = 2
     

        partiallycoherent = pixis_image_norm
        #pixis_profile_avg_dataset[imageid]
        (partiallycoherent_profile, fullycoherent_opt_list, fullycoherent_profile_opt_list,  partiallycoherent_rec_list, partiallycoherent_rec_profile_list, partiallycoherent_rec_profile_min_list, delta_rec_min_list, delta_profiles_cropped_list, sigma_F_gamma_um_opt, sigma_F_gamma_um_list, F_gamma_list, abs_gamma_list, xi_um_list, I_bp, dX_2, cor_list, cor_profiles_list, cor_profiles_list, index_opt, chi2distance_list
         )= deconvmethod_1d(
            partiallycoherent,
            z,
            dX_1,
            pixis_avg_width,
            int(pixis_centery_px),
            _lambda_nm_fit * 1e-9,
            sigma_F_gamma_um_min,
            sigma_F_gamma_um_max,
            sigma_F_gamma_um_stepsize,
            200,
        )

    
        end = datetime.now()
        time_taken = end - start
        print(time_taken)
        print(sigma_F_gamma_um_opt)
        print(xi_um_list[0])

        gc.collect()

display(Javascript('''google.colab.output.setIframeHeight(0, true, {maxHeight: 5000})''')) # https://stackoverflow.com/a/57346765

# the minimum can be either higher than the recorded one or lower
# how to find the range, where the minium is lower than the recorded and until it becomes zero?

def deconvmethod_1d_v2(partiallycoherent, z, dX_1, profilewidth, pixis_centery_px, wavelength, sigma_F_gamma_um_min, sigma_F_gamma_um_max, sigma_F_gamma_um_stepsize, xi_um_guess, crop_px):

    
    #number of pixels
    n = partiallycoherent.shape[0]
    nx = n
    ny = nx


    # pixel size of the detector dX_1
    
    dY_1 = dX_1

    # 2D grid and axes at the CCD:
    #x = np.arange(-n/2, n/2, 1) * dX_1
    #y = np.arange(-n/2, n/2, 1) * dX_1
    x = np.arange(-n/2, n/2, 1)
    y = np.arange(-n/2, n/2, 1)
    X1_axis, Y1_axis = np.meshgrid(x*dX_1, y*dX_1, sparse=False)
    #X1_axis, Y1_axis = np.meshgrid(x, y, sparse=False)


    # "pixelsize" at the pinholes:
    dX_2 = wavelength*z/(n*dX_1)
    dY_2 = wavelength*z/(n*dY_1)

    # 2D grid and axes at the double pinholes:
    X2_axis, Y2_axis = np.meshgrid(x*dX_2, y*dY_2, sparse=False)


    
    #psf = gauss2d(X1_axis,Y1_axis,1.9*13*1e-6)
    #psf = psf / np.max(psf)
    #sigma_F_gamma_um = 24.7
    
    
    sigma_F_gamma_um_list = np.arange(sigma_F_gamma_um_min,sigma_F_gamma_um_max,sigma_F_gamma_um_stepsize)
    listlength = len(sigma_F_gamma_um_list)
    xi_um_list = np.array(listlength * [np.nan])
    
    
    
    cor_list = np.array(listlength * [np.nan])
    cor_profiles_list = np.array(listlength * [np.nan])
    
    fullycoherent_profile_min_opt_list = np.array(listlength * [np.nan])
    fullycoherent_profile_opt_list = []
    fullycoherent_opt_list = []
    partiallycoherent_rec_list = []
    partiallycoherent_rec_profile_list = []
    partiallycoherent_rec_profile_min_list = np.array(listlength * [np.nan])
    delta_rec_min_list = np.array(listlength * [np.nan])
    delta_profiles_cropped_list = np.array(listlength * [np.nan])
    chi2distance_list = np.array(listlength * [np.nan])
    
    F_gamma_list = []
    gamma_list = []
    abs_gamma_list = []
    
    crop_px = 200
    

    
    fig = plt.figure(constrained_layout=False, figsize=(10,6), dpi=300)

    gs = gridspec.GridSpec(8, 3, figure=fig)

    ax00 = fig.add_subplot(gs[0, 0])
    ax10 = fig.add_subplot(gs[1, 0])
    ax20 = fig.add_subplot(gs[2, 0])
    ax30 = fig.add_subplot(gs[3, 0])
    ax40 = fig.add_subplot(gs[4, 0])
    ax50 = fig.add_subplot(gs[5, 0])
    ax60 = fig.add_subplot(gs[6, 0])
    ax70 = fig.add_subplot(gs[7, 0])

    ax = fig.add_subplot(gs[:, 1:])
    
    
    
    # ax = axs[0]
    # ax.plot(sigma_y_F_gamma_um_list, cor_list)
    # ax.set_ylabel('cor')

    # ax = axs[1]
    # ax.plot(sigma_y_F_gamma_um_list, cor_profiles_list)
    # ax.set_ylabel('cor profiles')

    # ax = axs[2]
    # ax.plot(sigma_y_F_gamma_um_list, chi2distance_list)
    # ax.set_ylabel('chi2distance')
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

    # ax = axs[3]
    # ax.plot(sigma_y_F_gamma_um_list, delta_rec_min_list)
    # ax.set_ylabel('delta minimum')

    # ax = axs[4]
    # ax.plot(sigma_y_F_gamma_um_list, delta_profiles_cropped_list)
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])
    # ax.set_ylabel('delta profiles cropped')

    # ax = axs[5]
    # ax.plot(sigma_y_F_gamma_um_list, xi_x_um_list)
    # ax.set_ylabel('xi_x')
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

    # ax = axs[6]
    # ax.plot(sigma_y_F_gamma_um_list, xi_y_um_list)
    # ax.set_ylabel('xi_y')
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

    # fig.tight_layout()
    # plt.xlim([sigma_y_F_gamma_um_list[0], sigma_y_F_gamma_um_list[-1]])
    # plt.show()

    z = 5781 * 1e-3
    z_0 = 1067 * 1e-3
    z_T = z + z_0
    z_eff = z * z_0 / (z_T)
    dX_1 = 13 * 1e-6

    j = 0
    index_opt = 0
    # for sigma_F_gamma_um in sigma_F_gamma_um_list:
    sigma_F_gamma_um_list = np.arange(sigma_F_gamma_um_min,sigma_F_gamma_um_max,sigma_F_gamma_um_stepsize)
    sigma_F_gamma_um_list_length = len(sigma_F_gamma_um_list)
    fullycoherent_profile_min_list = np.array(sigma_F_gamma_um_list_length * [np.nan])
    i = 0


    partiallycoherent_profile = np.mean(partiallycoherent[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
    partiallycoherent_profile = normalize(partiallycoherent_profile)

    # see https://stackoverflow.com/a/52672859
    # fig, axs = plt.subplots(nrows=1,ncols=1, sharex=True, figsize=(5,5))
    # ax = axs
    # ax.set_ylabel('fully coherent profile min')
    # fig.tight_layout()
    
    

    ax00.cla()
    ax10.cla()
    ax20.cla()
    ax30.cla()
    ax40.cla()
    ax50.cla()
    ax60.cla()
    ax70.cla()
    
    ax00.plot(sigma_F_gamma_um_list, cor_list)
    ax00.set_ylabel('cor')
    ax20.axvline(sigma_F_gamma_um_list[index_opt])
    ax00.set_xlim([sigma_F_gamma_um_list[0], sigma_F_gamma_um_list[-1]])

    
    ax10.plot(sigma_F_gamma_um_list, cor_profiles_list)
    ax10.set_ylabel('cor profiles')
    ax20.axvline(sigma_F_gamma_um_list[index_opt])
    ax10.set_xlim([sigma_F_gamma_um_list[0], sigma_F_gamma_um_list[-1]])

    
    ax20.plot(sigma_F_gamma_um_list, chi2distance_list)
    ax20.set_ylabel('chi2distance')
    ax20.axvline(sigma_F_gamma_um_list[index_opt])
    ax20.set_xlim([sigma_F_gamma_um_list[0], sigma_F_gamma_um_list[-1]])

    
    ax30.plot(sigma_F_gamma_um_list, delta_rec_min_list)
    ax30.set_ylabel('delta minimum')
    ax30.set_xlim([sigma_F_gamma_um_list[0], sigma_F_gamma_um_list[-1]])

    
    ax40.plot(sigma_F_gamma_um_list, delta_profiles_cropped_list)
    ax40.axvline(sigma_F_gamma_um_list[index_opt])
    ax40.set_ylabel('delta profiles cropped')
    ax40.set_xlim([sigma_F_gamma_um_list[0], sigma_F_gamma_um_list[-1]])

    
    ax50.plot(sigma_F_gamma_um_list, xi_um_list)
    ax50.set_ylabel('xi')
    ax50.axvline(sigma_F_gamma_um_list[index_opt])
    ax50.set_xlim([sigma_F_gamma_um_list[0], sigma_F_gamma_um_list[-1]])

    # guess sigma_F_gamma_um to be the same as the beams rms width
    
    sigma_F_gamma_um_guess = calc_sigma_F_gamma_um(xi_um_guess, n, dX_1, wavelength*1e9, False) 
    sigma_F_gamma_um = sigma_F_gamma_um_guess

    sigma_F_gamma_um_list = []
    fullycoherent_profile_min_list = []

    # for sigma_F_gamma_um in sigma_F_gamma_um_list:
    i = 0
    for factor in np.arange(1,4):

      # sigma_F_gamma = sigma_F_gamma_um * 1e-6
      
      F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_F_gamma_um*1e-6/dX_1, sigma_F_gamma_um*1e-6/dX_1)
      #psf = gauss2d(X1_axis,Y1_axis,1.9)
      sigma_F_gamma_um_list.append(sigma_F_gamma_um)

      # Restore Image using Richardson-Lucy algorithm
      #fullycoherent = restoration.richardson_lucy(partiallycoherent, psf, 5)
      fullycoherent = restoration.wiener(partiallycoherent, F_gamma, 1)
      #fullycoherent = np.real(deconvolve(partiallycoherent, psf))

      fullycoherent = fullycoherent / np.max(fullycoherent[200:-200,200:-200])
      fullycoherent_profile = np.mean(fullycoherent[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
      fullycoherent_profile = fullycoherent_profile / np.max(fullycoherent_profile[200:-200]) # ignore what happens on the edges

      fullycoherent_profile_min = np.min(fullycoherent_profile[200:-200]) # ignore what happens on the edges
      fullycoherent_profile_min_list.append(fullycoherent_profile_min)
      
      
      ax70.cla()
      ax70.scatter(sigma_F_gamma_um_list, fullycoherent_profile_min_list)
      ax70.set_xlim([sigma_F_gamma_um_min, sigma_F_gamma_um_max])
      ax70.set_ylim([-np.min(partiallycoherent_profile[200:-200]), np.min(partiallycoherent_profile[200:-200])])
      ax70.axhline(0, color='k')
      # plt.title('sigma_x_F_gamma=' + str(sigma_x_F_gamma_um) + ' sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min))


      n = partiallycoherent_profile.shape[0]
      xdata = np.linspace((-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3, n)

      ax.cla()
      ax.plot(xdata, partiallycoherent_profile, 'b-', label='measured partially coherent', linewidth=1)
      ax.plot(xdata, fullycoherent_profile, 'r-', label='recovered fully coherent', linewidth=1)
      # ax.plot(xdata, partiallycoherent_rec_profile_list[index_opt], 'g-', label='recovered partially coherent', linewidth=1)
      #plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
      ax.axhline(0, color='k')
      ax.set_xlabel('x / mm', fontsize = 8)
      ax.set_ylabel('Intensity / a.u.', fontsize = 8)
      ax.set_xlim([xdata[0], xdata[-1]])
      # plt.legend()

      # plt.title('d / $\mu$m = '+str(int(separation_um)) + ' coherence length $\\xi_x$ / $\mu$m = ' + str(round(xi_x_um_list[index_opt],2)) + ' $\\xi_y$ / $\mu$m = ' + str(round(xi_y_um_list[index_opt],2)), fontsize=16)




      # see https://stackoverflow.com/a/29675706
      display(plt.gcf())
      clear_output(wait=True)
      # plt.show()

      if fullycoherent_profile_min<0:
        sigma_F_gamma_um = sigma_F_gamma_um/2
      else:
        sigma_F_gamma_um = sigma_F_gamma_um*1.5
      
      i = i + 1

      # if fullycoherent_profile_min<0:
      #   break
      # else:
      #   i = i + 1

    
            

    print('fitting...')
    # sigma_x_F_gamma_um_opt = sigma_x_F_gamma_um_list[i-1]
    xdata = np.asarray(sigma_F_gamma_um_list) # why i+1? should be i?
    ydata = np.asarray(fullycoherent_profile_min_list)
    print(xdata)
    print(ydata)
    def func(x, a, b, c):
      return a*x**2 + b*x + c
    popt_func, pcov_func = curve_fit(func, xdata, ydata)
    a = popt_func[0]
    b = popt_func[1]
    c = popt_func[2]
    
    sigma_F_gamma_um_opt = brenth(func, np.min(xdata), np.max(xdata), args=(a,b,c))
    
    ax70.plot(np.asarray(sigma_F_gamma_um_list), func(np.asarray(sigma_F_gamma_um_list), a, b, c))
    ax70.axvline(sigma_F_gamma_um_opt)
    
    display(plt.gcf())
    clear_output(wait=True)
    # input("Press Enter to continue...")

    sigma_F_gamma = sigma_F_gamma_um_opt * 1e-6
    
    F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_F_gamma/dX_1, sigma_F_gamma/dX_1)
    #psf = gauss2d(X1_axis,Y1_axis,1.9)

    # Restore Image using Richardson-Lucy algorithm
    #fullycoherent = restoration.richardson_lucy(partiallycoherent, psf, 5)
    fullycoherent_opt = restoration.wiener(partiallycoherent, F_gamma, 1)
    #fullycoherent = np.real(deconvolve(partiallycoherent, psf))



    fullycoherent_opt = fullycoherent_opt / np.max(fullycoherent_opt[200:-200,200:-200])

    
    fullycoherent_profile_opt = np.mean(fullycoherent_opt[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
    #fullycoherent_profile = normalize(fullycoherent_profile)
    fullycoherent_profile_opt = fullycoherent_profile_opt / np.max(fullycoherent_profile_opt[200:-200]) # ignore what happens on the edges

    fullycoherent_profile_min_opt = np.min(fullycoherent_profile_opt[200:-200]) # ignore what happens on the edges
    



    # # fine-tuning in stepsize of 0.1

    # sigma_x_F_gamma_um_list = np.arange(sigma_x_F_gamma_um_opt,sigma_x_F_gamma_um_opt+1,0.05)
    # sigma_x_F_gamma_um_list_length = len(sigma_x_F_gamma_um_list)
    # fullycoherent_profile_min_list = np.array(sigma_x_F_gamma_um_list_length * [np.nan])
    # fullycoherent_list = []
    # fullycoherent_profile_list = []
    
    # i = 0
    # # fig, axs = plt.subplots(nrows=1,ncols=1, sharex=True, figsize=(5,5))
    # # ax = axs
    # for sigma_x_F_gamma_um in sigma_x_F_gamma_um_list:

    #     sigma_x_F_gamma = sigma_x_F_gamma_um * 1e-6
    #     sigma_y_F_gamma = sigma_y_F_gamma_um * 1e-6
    #     F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma/dX_1, sigma_y_F_gamma/dX_1)
    #     #psf = gauss2d(X1_axis,Y1_axis,1.9)

    #     # Restore Image using Richardson-Lucy algorithm
    #     #fullycoherent = restoration.richardson_lucy(partiallycoherent, psf, 5)
    #     fullycoherent = restoration.wiener(partiallycoherent, F_gamma, 1)
    #     #fullycoherent = np.real(deconvolve(partiallycoherent, psf))



    #     fullycoherent = fullycoherent / np.max(fullycoherent[200:-200,200:-200])
    #     fullycoherent_list.append(fullycoherent)
        

    #     fullycoherent_profile = np.mean(fullycoherent[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
    #     #fullycoherent_profile = normalize(fullycoherent_profile)
    #     fullycoherent_profile = fullycoherent_profile / np.max(fullycoherent_profile[200:-200]) # ignore what happens on the edges
    #     fullycoherent_profile_list.append(fullycoherent_profile)

    #     fullycoherent_profile_min = np.min(fullycoherent_profile[200:-200]) # ignore what happens on the edges
    #     fullycoherent_profile_min_list[i] = fullycoherent_profile_min

    #     # print('sigma_x_F_gamma=' + str(sigma_x_F_gamma_um) + ' sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min))

    #     # clear_output(wait=True)
    #     # plt.plot(sigma_x_F_gamma_um_list, fullycoherent_profile_min_list)
    #     # ax.set_ylabel('fully coherent profile min')
    #     # plt.xlim([sigma_x_F_gamma_um_list[0], sigma_x_F_gamma_um_list[-1]])
    #     # plt.ylim([0, np.min(partiallycoherent_profile[200:-200])])
    #     # # plt.title('sigma_x_F_gamma=' + str(sigma_x_F_gamma_um) + ' sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min))
    #     # plt.show()


    #     ax70.cla()
    #     ax70.plot(sigma_x_F_gamma_um_list, fullycoherent_profile_min_list)
    #     ax70.set_xlim([sigma_x_F_gamma_um_list[0], sigma_x_F_gamma_um_list[-1]])
    #     ax70.set_ylim([-0.1*np.min(partiallycoherent_profile[200:-200]), np.min(partiallycoherent_profile[200:-200])])
    #     ax70.axhline(0, color='k')
    #     # plt.title('sigma_x_F_gamma=' + str(sigma_x_F_gamma_um) + ' sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min))






    #     n = partiallycoherent_profile.shape[0]
    #     xdata = np.linspace((-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3, n)

    #     ax.cla()
    #     ax.plot(xdata, partiallycoherent_profile, 'b-', label='measured partially coherent', linewidth=1)
    #     ax.plot(xdata, fullycoherent_profile, 'r-', label='recovered fully coherent', linewidth=1)
    #     # ax.plot(xdata, partiallycoherent_rec_profile_list[index_opt], 'g-', label='recovered partially coherent', linewidth=1)
    #     #plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
    #     ax.axhline(0, color='k')
    #     ax.set_xlabel('x / mm', fontsize = 8)
    #     ax.set_ylabel('Intensity / a.u.', fontsize = 8)
    #     ax.set_xlim([xdata[0], xdata[-1]])
    #     # plt.legend()

    #     # plt.title('d / $\mu$m = '+str(int(separation_um)) + ' coherence length $\\xi_x$ / $\mu$m = ' + str(round(xi_x_um_list[index_opt],2)) + ' $\\xi_y$ / $\mu$m = ' + str(round(xi_y_um_list[index_opt],2)), fontsize=16)




    #     # see https://stackoverflow.com/a/29675706
    #     display(plt.gcf())
    #     clear_output(wait=True)
    #     # plt.show()



    #     if fullycoherent_profile_min<0:
    #         break
    #     i = i + 1
    # sigma_x_F_gamma_um_opt = sigma_x_F_gamma_um_list[i-1]
    # fullycoherent_opt = fullycoherent_list[i-1]
    fullycoherent_opt_list.append(fullycoherent_opt)
    # fullycoherent_profile_opt = fullycoherent_profile_list[i-1]
    fullycoherent_profile_opt_list.append(fullycoherent_profile_opt)
    # fullycoherent_profile_min_opt = fullycoherent_profile_min_list[i-1]
    fullycoherent_profile_min_opt_list[j] = fullycoherent_profile_min_opt
    
    F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_F_gamma_um_opt*1e-6/dX_1, sigma_F_gamma_um*1e-6/dX_1)
    F_gamma_list.append(F_gamma)
    gamma = fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(F_gamma)))
    gamma_list.append(gamma)

    partiallycoherent_rec = np.abs(convolve(fullycoherent_opt,F_gamma))
    partiallycoherent_rec = normalize(partiallycoherent_rec)
    partiallycoherent_rec_list.append(partiallycoherent_rec)
    partiallycoherent_rec_profile = np.mean(partiallycoherent_rec[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
    partiallycoherent_rec_profile = normalize(partiallycoherent_rec_profile)
    partiallycoherent_rec_profile_list.append(partiallycoherent_rec_profile)
    partiallycoherent_rec_profile_min_list[j] = np.min(partiallycoherent_rec_profile)
    #partiallycoherent_rec_profile = partiallycoherent_rec_profile / partiallycoherent_rec_profile[np.where(partiallycoherent_profile == 1.0)[0][0]]
    cor = corr2(partiallycoherent, partiallycoherent_rec)
    cor_profiles = corr2(partiallycoherent_profile, partiallycoherent_rec_profile)
    cor_list[j] = corr2(partiallycoherent, partiallycoherent_rec)
    cor_profiles_list[j] = cor_profiles
    #sigma_y_F_gamma_um_opt = sigma_y_F_gamma_um

    xdata = np.linspace((-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3, n)
    ax.cla()
    ax.plot(xdata, partiallycoherent_profile, 'b-', label='measured partially coherent', linewidth=1)
    ax.plot(xdata, fullycoherent_profile_opt, 'r-', label='recovered fully coherent', linewidth=1)
    ax.plot(xdata, partiallycoherent_rec_profile_list[index_opt], 'g-', label='recovered partially coherent', linewidth=1)
    #plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
    ax.axhline(0, color='k')
    ax.set_xlabel('x / mm', fontsize = 8)
    ax.set_ylabel('Intensity / a.u.', fontsize = 8)
    ax.set_xlim([xdata[0], xdata[-1]])
    display(plt.gcf())
    clear_output(wait=True)
    
    
    delta_profiles_cropped_list[j] = np.sum(partiallycoherent_profile[crop_px:-crop_px] - partiallycoherent_rec_profile[crop_px:-crop_px])
    
    
#         print('sigma_x_F_gamma_opt=' + str(sigma_x_F_gamma_um_opt) + 'sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min_list[i-1]) + '\\' + ' correlation partiallycohernet measurement and reconstruction = ' + str(round(cor*100,2)) + '%')


    # determine chi2 distance
    number_of_bins = 100
    hist1, bin_edges1 = np.histogram(partiallycoherent.ravel(), bins=np.linspace(0,1,number_of_bins))
    hist2, bin_edges2 = np.histogram(partiallycoherent_rec.ravel(), bins=np.linspace(0,1,number_of_bins))
    chi2distance_list[j] = chi2_distance(hist1, hist2)

    index_opt = np.where(chi2distance_list == np.nanmin(chi2distance_list))[0][0]


    # determine difference of miniumum of measured and reconstructed profile
    delta_rec_min_list[j] = np.min(partiallycoherent_rec_profile) - np.min(partiallycoherent_profile)

    

    xdata = list(range(n))
    ydata = fullycoherent[pixis_centery_px,:]
    ydata = ydata / np.max(ydata)
    

    
    abs_gamma = np.abs(gamma)
    abs_gamma = abs_gamma / np.max(abs_gamma)
    abs_gamma_list.append(abs_gamma)
    xdata = list(range(n))
    ydata = abs_gamma[int(n/2),:]
    p0 = (int(n/2), 1)
    popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
    xi_px = popt_gauss[1]/2
    xi_um = xi_px * dX_2 * 1e6
    xi_um_list[j] = xi_um
    
    
    # xdata = list(range(n))
    # ydata = abs_gamma[:,int(n/2)]
    # p0 = (int(n/2), 1)
    # popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
    # xi_px = popt_gauss[1]/2
    # xi_um = xi_y_px * dX_2 * 1e6
    # xi_um_list[j] = xi_um
    
    #print('coherence length xi/um = ' + str(xi_um))


        
        
    
    # index_opt = np.where( np.abs(partiallycoherent_rec_profile_min_list - np.min(partiallycoherent_profile)) == np.min(np.abs(partiallycoherent_rec_profile_min_list - np.min(partiallycoherent_profile)) ) )[0][0]
    
        
    A_bp = fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(np.sqrt(partiallycoherent))))  # amplitude
    I_bp = np.abs(A_bp)**2  # intensity
    
    return (partiallycoherent_profile, fullycoherent_opt_list, fullycoherent_profile_opt_list,  partiallycoherent_rec_list, partiallycoherent_rec_profile_list, partiallycoherent_rec_profile_min_list, delta_rec_min_list, delta_profiles_cropped_list, sigma_F_gamma_um_opt, sigma_F_gamma_um_list, F_gamma_list, abs_gamma_list, xi_um_list, I_bp, dX_2, cor_list, cor_profiles_list, cor_profiles_list, index_opt, chi2distance_list)

calc_sigma_F_gamma_um(930, n, dX_1, 13.5, False)

# hdf5_file_name_image = hdf5_file_name_image_widget.value
# pixis_avg_width = pixis_avg_width


do_deconvmethod = True
savefigure = False
    #do_deconvmethod = True

#imageid = imageid_widget.value

imageid_excluded = []

if do_deconvmethod == True:

#     imageids_by_energy_hall = get_imageids_with_bgs(beamposition_horizontal_interval)
#     imageids = imageids_by_energy_hall
#     sequence_center = int((len(imageids)-1)/2)

    # quick run:
    #imageids = imageids[sequence_center-5:sequence_center+5]
    # rest of the sequence:
#     imageids = imageids[0:sequence_center-5-1] + imageids[sequence_center+5+1:]
    # manual selection:
#     imageids = [30, 6, 5, 46, 27, 3, 8, 16, 54, 50, 52, 23, 42, 26, 43]

    # df = df0[(df0['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & df0['imageid'].isin(imageids_by_energy_hall)]


    

    count = 0

    from datetime import datetime

    time_taken = 0

    with h5py.File(dph_settings_bgsubtracted_widget.label, 'r') as hdf5_file:
      imageids = hdf5_file['/bgsubtracted/imageid'][:]
    for imageid in [imageids[0]]:
    # for imageid in imageids:
        
#         _lambda_nm_fit = df0[(df0['hdf5_file_name'] == hdf5_file_name_image_widget.value) & (df0['pinholes'] == dataset_image_args_widget.value[2]) & (df0['imageid']==imageid)]['_lambda_nm_fit'].tolist()[0]

        
        hdf5_file_path = dph_settings_bgsubtracted_widget.value
        with h5py.File(hdf5_file_path, 'r') as hdf5_file:
          pixis_image_norm = hdf5_file['/bgsubtracted/pixis_image_norm'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
          pixis_profile_avg = hdf5_file['/bgsubtracted/pixis_profile_avg'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
          timestamp_pulse_id = hdf5_file['Timing/time stamp/fl2user1'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][2]
          pixis_centery_px = hdf5_file['/bgsubtracted/pixis_centery_px'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][0]
          print(pixis_centery_px)

        ph = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['pinholes'].iloc[0]
        separation_um = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['separation_um'].iloc[0]
        orientation = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['orientation'].iloc[0]
        setting_wavelength_nm = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0]
        energy_hall_uJ = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['energy hall'].iloc[0]
        _lambda_nm_fit = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0] # is this stored in df0? get it from profile_fitting?
        
        hdf5_file_name_image = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['hdf5_file_name'].iloc[0]
        pixis_avg_width = 200 # random number, store in hdf5?
        beamposition_horizontal_interval = 1000 # random number, store in hdf5?
        
        

        count = count + 1
        time_left = (len(imageids) + 1 - count) * time_taken

        start = datetime.now()

        z = 5781 * 1e-3
        z_0 = 1067 * 1e-3
        z_T = z + z_0
        z_eff = z * z_0 / (z_T)
        dX_1 = 13 * 1e-6

        print('imageid=' + str(imageid) + ' ' + str(round(count/(len(imageids)+1)*100,2)) +'% ' + str('time left=') + str(time_left)  + ' lambda_nm_fit='+str(_lambda_nm_fit))
        #sigma_F_gamma_um_max = 60
        #partiallycoherent_profile, fullycoherent, fullycoherent_profile, partiallycoherent_rec_profile, partiallycoherent_rec_profile, sigma_F_gamma_um_opt, F_gamma, abs_gamma, xi_um, I_bp, dX_2, cor = deconvmethod(partiallycoherent, z, dX_1, pixis_avg_width, int(pixis_centery_px),_lambda_nm_fit[imageid]*1e-9, sigma_F_gamma_um_max)

        # How to guess these time-savingly???
        sigma_F_gamma_um_min = 5
        sigma_F_gamma_um_max = 30
        sigma_F_gamma_um_stepsize = 2
     

        partiallycoherent = pixis_image_norm
        #pixis_profile_avg_dataset[imageid]
        xi_um_guess = 463
        (partiallycoherent_profile, fullycoherent_opt_list, fullycoherent_profile_opt_list,  partiallycoherent_rec_list, partiallycoherent_rec_profile_list, partiallycoherent_rec_profile_min_list, delta_rec_min_list, delta_profiles_cropped_list, sigma_F_gamma_um_opt, sigma_F_gamma_um_list, F_gamma_list, abs_gamma_list, xi_um_list, I_bp, dX_2, cor_list, cor_profiles_list, cor_profiles_list, index_opt, chi2distance_list
         )= deconvmethod_1d_v2(
            partiallycoherent,
            z,
            dX_1,
            pixis_avg_width,
            int(pixis_centery_px),
            _lambda_nm_fit * 1e-9,
            sigma_F_gamma_um_min,
            sigma_F_gamma_um_max,
            sigma_F_gamma_um_stepsize,
            xi_um_guess,
            200,
        )

    
        end = datetime.now()
        time_taken = end - start
        print(time_taken)
        print(sigma_F_gamma_um_opt)
        print(xi_um_list[0])

        gc.collect()

display(Javascript('''google.colab.output.setIframeHeight(0, true, {maxHeight: 5000})''')) # https://stackoverflow.com/a/57346765

"""### Scan in both x and y"""

def deconvmethod_2d(partiallycoherent, z, dX_1, profilewidth, pixis_centery_px, wavelength, sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max, sigma_y_F_gamma_um_min, sigma_y_F_gamma_um_max, sigma_y_F_gamma_um_stepsize, sigma_x_F_gamma_um_stepsize, xi_um_guess, crop_px):
    
    #number of pixels
    n = partiallycoherent.shape[0]
    nx = n
    ny = nx

    # pixel size of the detector dX_1
    dY_1 = dX_1

    # 2D grid and axes at the CCD:
    #x = np.arange(-n/2, n/2, 1) * dX_1
    #y = np.arange(-n/2, n/2, 1) * dX_1
    x = np.arange(-n/2, n/2, 1)
    y = np.arange(-n/2, n/2, 1)
    X1_axis, Y1_axis = np.meshgrid(x*dX_1, y*dX_1, sparse=False)
    #X1_axis, Y1_axis = np.meshgrid(x, y, sparse=False)

    # "pixelsize" at the pinholes:
    dX_2 = wavelength*z/(n*dX_1)
    dY_2 = wavelength*z/(n*dY_1)

    # 2D grid and axes at the double pinholes:
    X2_axis, Y2_axis = np.meshgrid(x*dX_2, y*dY_2, sparse=False)
    
    #psf = gauss2d(X1_axis,Y1_axis,1.9*13*1e-6)
    #psf = psf / np.max(psf)
    #sigma_F_gamma_um = 24.7
        
    sigma_y_F_gamma_um_list = np.arange(sigma_y_F_gamma_um_min,sigma_y_F_gamma_um_max,sigma_y_F_gamma_um_stepsize)
    listlength = len(sigma_y_F_gamma_um_list)
    # xi_x_um_list = np.array(listlength * [np.nan])
    xi_x_um_list = []
    # xi_y_um_list = np.array(listlength * [np.nan])
    xi_y_um_list = []
        
    # cor_list = np.array(listlength * [np.nan])
    cor_list = []
    # cor_profiles_list = np.array(listlength * [np.nan])
    cor_profiles_list = []
    
    # fullycoherent_profile_min_opt_list = np.array(listlength * [np.nan])
    fullycoherent_profile_min_opt_list = []
    fullycoherent_profile_opt_list = []
    fullycoherent_opt_list = []
    partiallycoherent_rec_list = []
    partiallycoherent_rec_profile_list = []
    # partiallycoherent_rec_profile_min_list = np.array(listlength * [np.nan])
    partiallycoherent_rec_profile_min_list = []
    # delta_rec_min_list = np.array(listlength * [np.nan])
    delta_rec_min_list = []
    # delta_profiles_cropped_list = np.array(listlength * [np.nan])
    delta_profiles_cropped_list = []
    # chi2distance_list = np.array(listlength * [np.nan])
    chi2distance_list = []
    
    F_gamma_list = []
    gamma_list = []
    abs_gamma_list = []
    
    crop_px = 200
    
    fig = plt.figure(constrained_layout=False, figsize=(10,6), dpi=300)
    gs = gridspec.GridSpec(8, 3, figure=fig)
    ax00 = fig.add_subplot(gs[0, 0])
    ax10 = fig.add_subplot(gs[1, 0])
    ax20 = fig.add_subplot(gs[2, 0])
    ax30 = fig.add_subplot(gs[3, 0])
    ax40 = fig.add_subplot(gs[4, 0])
    ax50 = fig.add_subplot(gs[5, 0])
    ax60 = fig.add_subplot(gs[6, 0])
    ax70 = fig.add_subplot(gs[7, 0])

    ax = fig.add_subplot(gs[:, 1:])
    
    
    
    # ax = axs[0]
    # ax.plot(sigma_y_F_gamma_um_list, cor_list)
    # ax.set_ylabel('cor')

    # ax = axs[1]
    # ax.plot(sigma_y_F_gamma_um_list, cor_profiles_list)
    # ax.set_ylabel('cor profiles')

    # ax = axs[2]
    # ax.plot(sigma_y_F_gamma_um_list, chi2distance_list)
    # ax.set_ylabel('chi2distance')
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

    # ax = axs[3]
    # ax.plot(sigma_y_F_gamma_um_list, delta_rec_min_list)
    # ax.set_ylabel('delta minimum')

    # ax = axs[4]
    # ax.plot(sigma_y_F_gamma_um_list, delta_profiles_cropped_list)
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])
    # ax.set_ylabel('delta profiles cropped')

    # ax = axs[5]
    # ax.plot(sigma_y_F_gamma_um_list, xi_x_um_list)
    # ax.set_ylabel('xi_x')
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

    # ax = axs[6]
    # ax.plot(sigma_y_F_gamma_um_list, xi_y_um_list)
    # ax.set_ylabel('xi_y')
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

    # fig.tight_layout()
    # plt.xlim([sigma_y_F_gamma_um_list[0], sigma_y_F_gamma_um_list[-1]])
    # plt.show()

    z = 5781 * 1e-3
    z_0 = 1067 * 1e-3
    z_T = z + z_0
    z_eff = z * z_0 / (z_T)
    dX_1 = 13 * 1e-6

    # guess sigma_y_F_gamma_um to be the same as the beams rms width    
    sigma_y_F_gamma_um_guess = calc_sigma_F_gamma_um(xi_um_guess, n, dX_1, wavelength*1e9, False) 
    sigma_y_F_gamma_um = sigma_y_F_gamma_um_guess
    sigma_y_F_gamma_um_list = []

    # for sigma_x_F_gamma_um in sigma_x_F_gamma_um_list:
    j = 0
    index_opt = 0
    for factor in np.arange(1,10):
        sigma_y_F_gamma_um_list.append(sigma_y_F_gamma_um)
    
    
    # for sigma_y_F_gamma_um in sigma_y_F_gamma_um_list:
        # sigma_x_F_gamma_um_list = np.arange(sigma_x_F_gamma_um_min,sigma_x_F_gamma_um_max,sigma_x_F_gamma_um_stepsize)
        # sigma_x_F_gamma_um_list_length = len(sigma_x_F_gamma_um_list)
        sigma_x_F_gamma_um_list = []
        # fullycoherent_profile_min_list = np.array(sigma_x_F_gamma_um_list_length * [np.nan])
        fullycoherent_profile_min_list = []
        


        partiallycoherent_profile = np.mean(partiallycoherent[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
        partiallycoherent_profile = normalize(partiallycoherent_profile)

        # see https://stackoverflow.com/a/52672859
        # fig, axs = plt.subplots(nrows=1,ncols=1, sharex=True, figsize=(5,5))
        # ax = axs
        # ax.set_ylabel('fully coherent profile min')
        # fig.tight_layout()
        
        

        # ax00.cla()
        # ax10.cla()
        # ax20.cla()
        # ax30.cla()
        # ax40.cla()
        # ax50.cla()
        # ax60.cla()
        ax70.cla()
        

        
        


        # guess sigma_x_F_gamma_um to be the same as the beams rms width    
        sigma_x_F_gamma_um_guess = calc_sigma_F_gamma_um(xi_um_guess, n, dX_1, wavelength*1e9, False) 
        sigma_x_F_gamma_um = sigma_x_F_gamma_um_guess

        # for sigma_x_F_gamma_um in sigma_x_F_gamma_um_list:
        i = 0
        for factor in np.arange(1,4):

          sigma_x_F_gamma = sigma_x_F_gamma_um * 1e-6
          sigma_y_F_gamma = sigma_y_F_gamma_um * 1e-6

          sigma_x_F_gamma_um_list.append(sigma_x_F_gamma_um)

          F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma/dX_1, sigma_y_F_gamma/dX_1)
          #psf = gauss2d(X1_axis,Y1_axis,1.9)

          # Restore Image using Richardson-Lucy algorithm
          #fullycoherent = restoration.richardson_lucy(partiallycoherent, psf, 5)
          fullycoherent = restoration.wiener(partiallycoherent, F_gamma, 1)
          #fullycoherent = np.real(deconvolve(partiallycoherent, psf))



          fullycoherent = fullycoherent / np.max(fullycoherent[200:-200,200:-200])

          
          fullycoherent_profile = np.mean(fullycoherent[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
          #fullycoherent_profile = normalize(fullycoherent_profile)
          fullycoherent_profile = fullycoherent_profile / np.max(fullycoherent_profile[200:-200]) # ignore what happens on the edges

          fullycoherent_profile_min = np.min(fullycoherent_profile[200:-200]) # ignore what happens on the edges
          fullycoherent_profile_min_list.append(fullycoherent_profile_min)
          
          # print('sigma_x_F_gamma=' + str(sigma_x_F_gamma_um) + ' sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min))


         

          # fig.tight_layout()
          
          
          

          # print('second column')
          
          # ax70.cla()
          # print(sigma_x_F_gamma_um_list)
          # print(fullycoherent_profile_min_list)
          ax70.scatter(sigma_x_F_gamma_um, fullycoherent_profile_min)
          ax70.set_xlim([sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max])
          ax70.set_ylim([-np.min(partiallycoherent_profile[200:-200]), np.min(partiallycoherent_profile[200:-200])])
          ax70.axhline(0, color='k')
          # plt.title('sigma_x_F_gamma=' + str(sigma_x_F_gamma_um) + ' sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min))






          n = partiallycoherent_profile.shape[0]
          xdata = np.linspace((-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3, n)

          ax.cla()
          ax.plot(xdata, partiallycoherent_profile, 'b-', label='measured partially coherent', linewidth=1)
          ax.plot(xdata, fullycoherent_profile, 'r-', label='recovered fully coherent', linewidth=1)
          # ax.plot(xdata, partiallycoherent_rec_profile_list[index_opt], 'g-', label='recovered partially coherent', linewidth=1)
          #plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
          ax.axhline(0, color='k')
          ax.set_xlabel('x / mm', fontsize = 8)
          ax.set_ylabel('Intensity / a.u.', fontsize = 8)
          # ax.set_xlim([xdata[0], xdata[-1]])
          # plt.legend()

          # plt.title('d / $\mu$m = '+str(int(separation_um)) + ' coherence length $\\xi_x$ / $\mu$m = ' + str(round(xi_x_um_list[index_opt],2)) + ' $\\xi_y$ / $\mu$m = ' + str(round(xi_y_um_list[index_opt],2)), fontsize=16)




          # see https://stackoverflow.com/a/29675706
          display(plt.gcf())
          clear_output(wait=True)
          # plt.show()

          if fullycoherent_profile_min<0:
            sigma_x_F_gamma_um = sigma_x_F_gamma_um/2
          else:
            sigma_x_F_gamma_um = sigma_x_F_gamma_um*1.2
          
          i = i + 1

        
                


        xdata = np.array(sigma_x_F_gamma_um_list)
        ydata = np.array(fullycoherent_profile_min_list)
        
        def func(x, a, b, c):
          return a*x**2 + b*x + c
        try:
          popt_func, pcov_func = curve_fit(func, xdata, ydata)
          a = popt_func[0]
          b = popt_func[1]
          c = popt_func[2]
        except:
          1
        
        
        sigma_x_F_gamma_um_opt = brenth(func, np.min(xdata), np.max(xdata), args=(a,b,c))
        
        ax70.plot(np.array(sigma_x_F_gamma_um_list), func(np.array(sigma_x_F_gamma_um_list), a, b, c))
        ax70.axvline(sigma_x_F_gamma_um_opt)
        
        # display(plt.gcf())
        # clear_output(wait=True)
        # input("Press Enter to continue...")

        sigma_x_F_gamma = sigma_x_F_gamma_um_opt * 1e-6
        sigma_y_F_gamma = sigma_y_F_gamma_um * 1e-6
        F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma/dX_1, sigma_y_F_gamma/dX_1)
        #psf = gauss2d(X1_axis,Y1_axis,1.9)

        # Restore Image using Richardson-Lucy algorithm
        #fullycoherent = restoration.richardson_lucy(partiallycoherent, psf, 5)
        fullycoherent_opt = restoration.wiener(partiallycoherent, F_gamma, 1)
        #fullycoherent = np.real(deconvolve(partiallycoherent, psf))



        fullycoherent_opt = fullycoherent_opt / np.max(fullycoherent_opt[200:-200,200:-200])

        
        fullycoherent_profile_opt = np.mean(fullycoherent_opt[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
        #fullycoherent_profile = normalize(fullycoherent_profile)
        fullycoherent_profile_opt = fullycoherent_profile_opt / np.max(fullycoherent_profile_opt[200:-200]) # ignore what happens on the edges

        fullycoherent_profile_min_opt = np.min(fullycoherent_profile_opt[200:-200]) # ignore what happens on the edges
        

        # sigma_x_F_gamma_um_opt = sigma_x_F_gamma_um_list[i-1]
        # fullycoherent_opt = fullycoherent_list[i-1]
        fullycoherent_opt_list.append(fullycoherent_opt)
        # fullycoherent_profile_opt = fullycoherent_profile_list[i-1]
        fullycoherent_profile_opt_list.append(fullycoherent_profile_opt)
        # fullycoherent_profile_min_opt = fullycoherent_profile_min_list[i-1]
        # fullycoherent_profile_min_opt_list[j] = fullycoherent_profile_min_opt
        
        F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma_um_opt*1e-6/dX_1, sigma_y_F_gamma_um*1e-6/dX_1)
        F_gamma_list.append(F_gamma)
        gamma = fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(F_gamma)))
        gamma_list.append(gamma)
    
        partiallycoherent_rec = np.abs(convolve(fullycoherent_opt,F_gamma))
        partiallycoherent_rec = normalize(partiallycoherent_rec)
        partiallycoherent_rec_list.append(partiallycoherent_rec)
        partiallycoherent_rec_profile = np.mean(partiallycoherent_rec[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
        partiallycoherent_rec_profile = normalize(partiallycoherent_rec_profile)
        partiallycoherent_rec_profile_list.append(partiallycoherent_rec_profile)
        # partiallycoherent_rec_profile_min_list[j] = np.min(partiallycoherent_rec_profile)
        partiallycoherent_rec_profile_min_list.append(np.min(partiallycoherent_rec_profile))
        #partiallycoherent_rec_profile = partiallycoherent_rec_profile / partiallycoherent_rec_profile[np.where(partiallycoherent_profile == 1.0)[0][0]]
        cor = corr2(partiallycoherent, partiallycoherent_rec)
        cor_profiles = corr2(partiallycoherent_profile, partiallycoherent_rec_profile)
        # cor_list[j] = corr2(partiallycoherent, partiallycoherent_rec)
        cor_list.append(corr2(partiallycoherent, partiallycoherent_rec))
        # cor_profiles_list[j] = cor_profiles
        cor_profiles_list.append(cor_profiles)
        #sigma_y_F_gamma_um_opt = sigma_y_F_gamma_um

        xdata = np.linspace((-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3, n)
        ax.cla()
        ax.plot(xdata, partiallycoherent_profile, 'b-', label='measured partially coherent', linewidth=1)
        ax.plot(xdata, fullycoherent_profile_opt, 'r-', label='recovered fully coherent', linewidth=1)
        ax.plot(xdata, partiallycoherent_rec_profile_list[index_opt], 'g-', label='recovered partially coherent', linewidth=1)
        #plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
        ax.axhline(0, color='k')
        ax.set_xlabel('x / mm', fontsize = 8)
        ax.set_ylabel('Intensity / a.u.', fontsize = 8)
        # ax.set_xlim([xdata[0], xdata[-1]])
        
        
        # delta_profiles_cropped_list[j] = np.sum(partiallycoherent_profile[crop_px:-crop_px] - partiallycoherent_rec_profile[crop_px:-crop_px])
        delta_profiles_cropped_list.append(np.sum(partiallycoherent_profile[crop_px:-crop_px] - partiallycoherent_rec_profile[crop_px:-crop_px]))
        
        
#         print('sigma_x_F_gamma_opt=' + str(sigma_x_F_gamma_um_opt) + 'sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min_list[i-1]) + '\\' + ' correlation partiallycohernet measurement and reconstruction = ' + str(round(cor*100,2)) + '%')


        # determine chi2 distance
        number_of_bins = 100
        hist1, bin_edges1 = np.histogram(partiallycoherent.ravel(), bins=np.linspace(0,1,number_of_bins))
        hist2, bin_edges2 = np.histogram(partiallycoherent_rec.ravel(), bins=np.linspace(0,1,number_of_bins))
        # chi2distance_list[j] = chi2_distance(hist1, hist2)
        chi2distance_list.append(chi2_distance(hist1, hist2))

        index_opt = np.where(chi2distance_list == np.nanmin(chi2distance_list))[0][0]


        # determine difference of miniumum of measured and reconstructed profile
        # delta_rec_min_list[j] = np.min(partiallycoherent_rec_profile) - np.min(partiallycoherent_profile)
        delta_rec_min_list.append(np.min(partiallycoherent_rec_profile) - np.min(partiallycoherent_profile))

        

        xdata = list(range(n))
        ydata = fullycoherent[pixis_centery_px,:]
        ydata = ydata / np.max(ydata)
        

        
        abs_gamma = np.abs(gamma)
        abs_gamma = abs_gamma / np.max(abs_gamma)
        abs_gamma_list.append(abs_gamma)
        xdata = list(range(n))
        ydata = abs_gamma[int(n/2),:]
        p0 = (int(n/2), 1)
        try:
          popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
        except:
          1
        xi_x_px = popt_gauss[1]/2
        xi_x_um = xi_x_px * dX_2 * 1e6
        # xi_x_um_list[j] = xi_x_um
        xi_x_um_list.append(xi_x_um)
        
        
        xdata = list(range(n))
        ydata = abs_gamma[:,int(n/2)]
        p0 = (int(n/2), 1)
        try:
          popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
        except:
          1
        xi_y_px = popt_gauss[1]/2
        xi_y_um = xi_y_px * dX_2 * 1e6
        # xi_y_um_list[j] = xi_y_um
        xi_y_um_list.append(xi_y_um)
        
        #print('coherence length xi/um = ' + str(xi_um))



        ax00.scatter(sigma_y_F_gamma_um_list[j], cor_list[j])
        ax00.set_ylabel('cor')
        ax00.axvline(sigma_y_F_gamma_um_list[index_opt])
        ax00.set_xlim([sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max])

        
        ax10.scatter(sigma_y_F_gamma_um_list[j], cor_profiles_list[j])
        ax10.set_ylabel('cor profiles')
        ax10.axvline(sigma_y_F_gamma_um_list[index_opt])
        ax10.set_xlim([sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max])

        
        ax20.scatter(sigma_y_F_gamma_um_list[j], chi2distance_list[j])
        ax20.set_ylabel('chi2distance')
        ax20.axvline(sigma_y_F_gamma_um_list[index_opt])
        ax20.set_xlim([sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max])

        
        ax30.scatter(sigma_y_F_gamma_um_list[j], delta_rec_min_list[j])
        ax30.set_ylabel('delta minimum')
        ax30.set_xlim([sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max])

        
        ax40.scatter(sigma_y_F_gamma_um_list[j], delta_profiles_cropped_list[j])
        ax40.axvline(sigma_y_F_gamma_um_list[index_opt])
        ax40.set_ylabel('delta profiles cropped')
        ax40.set_xlim([sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max])

        
        ax50.scatter(sigma_y_F_gamma_um_list[j], xi_x_um_list[j])
        ax50.set_ylabel('xi_x')
        ax50.axvline(sigma_y_F_gamma_um_list[index_opt])
        ax50.set_xlim([sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max])

        
        ax60.scatter(sigma_y_F_gamma_um_list[j], xi_y_um_list[j])
        ax60.set_ylabel('xi_y')
        ax60.axvline(sigma_y_F_gamma_um_list[index_opt])
        ax60.set_xlim([sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max])

        display(plt.gcf())
        clear_output(wait=True)


        
        if j == 0:
          sigma_y_F_gamma_um = sigma_y_F_gamma_um * 1.3

        else:
          stepsize = (sigma_y_F_gamma_um_list[1] - sigma_y_F_gamma_um_list[0])
          if chi2distance_list[j] > chi2distance_list[j-1]:
            sigma_y_F_gamma_um = sigma_y_F_gamma_um_list[j] - stepsize
          else:
            sigma_y_F_gamma_um = sigma_y_F_gamma_um_list[j] + stepsize
          # sigma_y_F_gamma_um = sigma_y_F_gamma_um_list[j] - ( chi2distance_list[j-1] - chi2distance_list[j] ) / (sigma_y_F_gamma_um_list[j-1] - sigma_y_F_gamma_um_list[j]) * (sigma_y_F_gamma_um_list[1] - sigma_y_F_gamma_um_list[0])


        j = j+1
        
        
    
    # index_opt = np.where( np.abs(partiallycoherent_rec_profile_min_list - np.min(partiallycoherent_profile)) == np.min(np.abs(partiallycoherent_rec_profile_min_list - np.min(partiallycoherent_profile)) ) )[0][0]
    
        
    A_bp = fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(np.sqrt(partiallycoherent))))  # amplitude
    I_bp = np.abs(A_bp)**2  # intensity
    
    return (partiallycoherent_profile, fullycoherent_opt_list, fullycoherent_profile_opt_list,  partiallycoherent_rec_list, partiallycoherent_rec_profile_list, partiallycoherent_rec_profile_min_list, delta_rec_min_list, delta_profiles_cropped_list, sigma_x_F_gamma_um_opt, sigma_y_F_gamma_um_list, F_gamma_list, abs_gamma_list, xi_x_um_list, xi_y_um_list, I_bp, dX_2, cor_list, cor_profiles_list, cor_profiles_list, index_opt, chi2distance_list)

# import warnings
# # warnings.filterwarnings('ignore')
# warnings.filterwarnings('default')

do_deconvmethod = True
savefigure = False

#imageid = imageid_widget.value

imageid_excluded = []

if do_deconvmethod == True:

    count = 0

    from datetime import datetime

    time_taken = 0

    with h5py.File(dph_settings_bgsubtracted_widget.label, 'r') as hdf5_file:
      imageids = hdf5_file['/bgsubtracted/imageid'][:]
    for imageid in [imageids[0]]:
    # for imageid in imageids:
        
        
        hdf5_file_path = dph_settings_bgsubtracted_widget.value
        with h5py.File(hdf5_file_path, 'r') as hdf5_file:
          pixis_image_norm = hdf5_file['/bgsubtracted/pixis_image_norm'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
          pixis_profile_avg = hdf5_file['/bgsubtracted/pixis_profile_avg'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
          timestamp_pulse_id = hdf5_file['Timing/time stamp/fl2user1'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][2]
          pixis_centery_px = hdf5_file['/bgsubtracted/pixis_centery_px'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][0]
          print(pixis_centery_px)

        ph = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['pinholes'].iloc[0]
        separation_um = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['separation_um'].iloc[0]
        orientation = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['orientation'].iloc[0]
        setting_wavelength_nm = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0]
        energy_hall_uJ = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['energy hall'].iloc[0]
        _lambda_nm_fit = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0] # is this stored in df0? get it from profile_fitting?
        
        hdf5_file_name_image = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['hdf5_file_name'].iloc[0]
        pixis_avg_width = 200 # random number, store in hdf5?
        beamposition_horizontal_interval = 1000 # random number, store in hdf5?
        
        

        count = count + 1
        time_left = (len(imageids) + 1 - count) * time_taken

        start = datetime.now()

        z = 5781 * 1e-3
        z_0 = 1067 * 1e-3
        z_T = z + z_0
        z_eff = z * z_0 / (z_T)
        dX_1 = 13 * 1e-6

        print('imageid=' + str(imageid) + ' ' + str(round(count/(len(imageids)+1)*100,2)) +'% ' + str('time left=') + str(time_left)  + ' lambda_nm_fit='+str(_lambda_nm_fit))
        #sigma_F_gamma_um_max = 60
        #partiallycoherent_profile, fullycoherent, fullycoherent_profile, partiallycoherent_rec_profile, partiallycoherent_rec_profile, sigma_F_gamma_um_opt, F_gamma, abs_gamma, xi_um, I_bp, dX_2, cor = deconvmethod(partiallycoherent, z, dX_1, pixis_avg_width, int(pixis_centery_px),_lambda_nm_fit[imageid]*1e-9, sigma_F_gamma_um_max)

        # How to guess these time-savingly???
        sigma_x_F_gamma_um_guess = 17
        sigma_x_F_gamma_um_min = sigma_x_F_gamma_um_guess/2
        sigma_x_F_gamma_um_max = sigma_x_F_gamma_um_guess*2
        sigma_x_F_gamma_um_stepsize = 2


        sigma_y_F_gamma_um_guess = 14
        sigma_y_F_gamma_um_min = sigma_y_F_gamma_um_guess - 8
        sigma_y_F_gamma_um_max = sigma_y_F_gamma_um_guess + 8
        sigma_y_F_gamma_um_stepsize = 2

        partiallycoherent = pixis_image_norm
        #pixis_profile_avg_dataset[imageid]
        xi_um_guess = 411
        (
            partiallycoherent_profile,
            fullycoherent_opt_list,
            fullycoherent_profile_opt_list,
            partiallycoherent_rec_list,
            partiallycoherent_rec_profile_list,
            partiallycoherent_rec_profile_min_list,
            delta_rec_min_list,
            delta_profiles_cropped_list,
            sigma_x_F_gamma_um_opt,
            sigma_y_F_gamma_um_list,
            F_gamma_list,
            abs_gamma_list,
            xi_x_um_list,
            xi_y_um_list,
            I_bp,
            dX_2,
            cor_list,
            cor_profiles_list,
            cor_profiles_cropped_list,
            index_opt,
            chi2distance_list,
        ) = deconvmethod_2d(
            partiallycoherent,
            z,
            dX_1,
            pixis_avg_width,
            int(pixis_centery_px),
            _lambda_nm_fit * 1e-9,
            sigma_x_F_gamma_um_min,
            sigma_x_F_gamma_um_max,
            sigma_y_F_gamma_um_min,
            sigma_y_F_gamma_um_max,
            sigma_y_F_gamma_um_stepsize,
            sigma_y_F_gamma_um_stepsize,
            xi_um_guess,
            200,
        )



        end = datetime.now()
        time_taken = end - start
        # print(time_taken)

 
        gc.collect()

display(Javascript('''google.colab.output.setIframeHeight(0, true, {maxHeight: 5000})''')) # https://stackoverflow.com/a/57346765

"""### scan only in x for a given y"""

def deconvmethod_2d_x(partiallycoherent, z, dX_1, profilewidth, pixis_centery_px, wavelength, sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max, sigma_y_F_gamma_um_min, sigma_y_F_gamma_um_max, sigma_y_F_gamma_um_stepsize, sigma_x_F_gamma_um_stepsize, sigma_y_F_gamma_um_guess, xi_um_guess, crop_px, create_figure):
    
    #number of pixels
    n = partiallycoherent.shape[0]
    nx = n
    ny = nx

    # pixel size of the detector dX_1
    dY_1 = dX_1

    # 2D grid and axes at the CCD:
    #x = np.arange(-n/2, n/2, 1) * dX_1
    #y = np.arange(-n/2, n/2, 1) * dX_1
    x = np.arange(-n/2, n/2, 1)
    y = np.arange(-n/2, n/2, 1)
    X1_axis, Y1_axis = np.meshgrid(x*dX_1, y*dX_1, sparse=False)
    #X1_axis, Y1_axis = np.meshgrid(x, y, sparse=False)

    # "pixelsize" at the pinholes:
    dX_2 = wavelength*z/(n*dX_1)
    dY_2 = wavelength*z/(n*dY_1)

    # 2D grid and axes at the double pinholes:
    X2_axis, Y2_axis = np.meshgrid(x*dX_2, y*dY_2, sparse=False)
    
    #psf = gauss2d(X1_axis,Y1_axis,1.9*13*1e-6)
    #psf = psf / np.max(psf)
    #sigma_F_gamma_um = 24.7
        
    sigma_y_F_gamma_um_list = np.arange(sigma_y_F_gamma_um_min,sigma_y_F_gamma_um_max,sigma_y_F_gamma_um_stepsize)
    listlength = len(sigma_y_F_gamma_um_list)
    # xi_x_um_list = np.array(listlength * [np.nan])
    xi_x_um_list = []
    # xi_y_um_list = np.array(listlength * [np.nan])
    xi_y_um_list = []
        
    # cor_list = np.array(listlength * [np.nan])
    cor_list = []
    # cor_profiles_list = np.array(listlength * [np.nan])
    cor_profiles_list = []
    
    # fullycoherent_profile_min_opt_list = np.array(listlength * [np.nan])
    fullycoherent_profile_min_opt_list = []
    fullycoherent_profile_opt_list = []
    fullycoherent_opt_list = []
    partiallycoherent_rec_list = []
    partiallycoherent_rec_profile_list = []
    # partiallycoherent_rec_profile_min_list = np.array(listlength * [np.nan])
    partiallycoherent_rec_profile_min_list = []
    # delta_rec_min_list = np.array(listlength * [np.nan])
    delta_rec_min_list = []
    # delta_profiles_cropped_list = np.array(listlength * [np.nan])
    delta_profiles_cropped_list = []
    # chi2distance_list = np.array(listlength * [np.nan])
    chi2distance_list = []
    
    F_gamma_list = []
    gamma_list = []
    abs_gamma_list = []
    
    crop_px = 200
    
    if create_figure == True:
      fig = plt.figure(constrained_layout=False, figsize=(10,6), dpi=300)
      gs = gridspec.GridSpec(8, 3, figure=fig)
      ax00 = fig.add_subplot(gs[0, 0])
      ax10 = fig.add_subplot(gs[1, 0])
      ax20 = fig.add_subplot(gs[2, 0])
      ax30 = fig.add_subplot(gs[3, 0])
      ax40 = fig.add_subplot(gs[4, 0])
      ax50 = fig.add_subplot(gs[5, 0])
      ax60 = fig.add_subplot(gs[6, 0])
      ax70 = fig.add_subplot(gs[7, 0])

      ax = fig.add_subplot(gs[:, 1:])
    
    
    
    # ax = axs[0]
    # ax.plot(sigma_y_F_gamma_um_list, cor_list)
    # ax.set_ylabel('cor')

    # ax = axs[1]
    # ax.plot(sigma_y_F_gamma_um_list, cor_profiles_list)
    # ax.set_ylabel('cor profiles')

    # ax = axs[2]
    # ax.plot(sigma_y_F_gamma_um_list, chi2distance_list)
    # ax.set_ylabel('chi2distance')
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

    # ax = axs[3]
    # ax.plot(sigma_y_F_gamma_um_list, delta_rec_min_list)
    # ax.set_ylabel('delta minimum')

    # ax = axs[4]
    # ax.plot(sigma_y_F_gamma_um_list, delta_profiles_cropped_list)
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])
    # ax.set_ylabel('delta profiles cropped')

    # ax = axs[5]
    # ax.plot(sigma_y_F_gamma_um_list, xi_x_um_list)
    # ax.set_ylabel('xi_x')
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

    # ax = axs[6]
    # ax.plot(sigma_y_F_gamma_um_list, xi_y_um_list)
    # ax.set_ylabel('xi_y')
    # ax.axvline(sigma_y_F_gamma_um_list[index_opt])

    # fig.tight_layout()
    # plt.xlim([sigma_y_F_gamma_um_list[0], sigma_y_F_gamma_um_list[-1]])
    # plt.show()

    z = 5781 * 1e-3
    z_0 = 1067 * 1e-3
    z_T = z + z_0
    z_eff = z * z_0 / (z_T)
    dX_1 = 13 * 1e-6

    # guess sigma_y_F_gamma_um to be the same as the beams rms width    
    # sigma_y_F_gamma_um_guess = calc_sigma_F_gamma_um(xi_um_guess, n, dX_1, wavelength*1e9, False) 
    sigma_y_F_gamma_um = sigma_y_F_gamma_um_guess
    sigma_y_F_gamma_um_list = []

    # for sigma_x_F_gamma_um in sigma_x_F_gamma_um_list:
    j = 0
    index_opt = 0
    # for factor in np.arange(1,10):



    sigma_y_F_gamma_um_list.append(sigma_y_F_gamma_um)


# for sigma_y_F_gamma_um in sigma_y_F_gamma_um_list:
    # sigma_x_F_gamma_um_list = np.arange(sigma_x_F_gamma_um_min,sigma_x_F_gamma_um_max,sigma_x_F_gamma_um_stepsize)
    # sigma_x_F_gamma_um_list_length = len(sigma_x_F_gamma_um_list)
    sigma_x_F_gamma_um_list = []
    # fullycoherent_profile_min_list = np.array(sigma_x_F_gamma_um_list_length * [np.nan])
    fullycoherent_profile_min_list = []
    


    partiallycoherent_profile = np.mean(partiallycoherent[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
    partiallycoherent_profile = normalize(partiallycoherent_profile)

    # see https://stackoverflow.com/a/52672859
    # fig, axs = plt.subplots(nrows=1,ncols=1, sharex=True, figsize=(5,5))
    # ax = axs
    # ax.set_ylabel('fully coherent profile min')
    # fig.tight_layout()
    
    

    # ax00.cla()
    # ax10.cla()
    # ax20.cla()
    # ax30.cla()
    # ax40.cla()
    # ax50.cla()
    # ax60.cla()
    if create_figure == True:
      ax70.cla()
    

    
    


    # guess sigma_x_F_gamma_um to be the same as the beams rms width    
    sigma_x_F_gamma_um_guess = calc_sigma_F_gamma_um(xi_um_guess, n, dX_1, wavelength*1e9, False) 
    sigma_x_F_gamma_um = sigma_x_F_gamma_um_guess

    # for sigma_x_F_gamma_um in sigma_x_F_gamma_um_list:
    i = 0
    for factor in np.arange(1,4):

      sigma_x_F_gamma = sigma_x_F_gamma_um * 1e-6
      sigma_y_F_gamma = sigma_y_F_gamma_um * 1e-6

      sigma_x_F_gamma_um_list.append(sigma_x_F_gamma_um)

      F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma/dX_1, sigma_y_F_gamma/dX_1)
      #psf = gauss2d(X1_axis,Y1_axis,1.9)

      # Restore Image using Richardson-Lucy algorithm
      #fullycoherent = restoration.richardson_lucy(partiallycoherent, psf, 5)
      fullycoherent = restoration.wiener(partiallycoherent, F_gamma, 1)
      #fullycoherent = np.real(deconvolve(partiallycoherent, psf))



      fullycoherent = fullycoherent / np.max(fullycoherent[200:-200,200:-200])

      
      fullycoherent_profile = np.mean(fullycoherent[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
      #fullycoherent_profile = normalize(fullycoherent_profile)
      fullycoherent_profile = fullycoherent_profile / np.max(fullycoherent_profile[200:-200]) # ignore what happens on the edges

      fullycoherent_profile_min = np.min(fullycoherent_profile[200:-200]) # ignore what happens on the edges
      fullycoherent_profile_min_list.append(fullycoherent_profile_min)
      
      # print('sigma_x_F_gamma=' + str(sigma_x_F_gamma_um) + ' sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min))


      

      # fig.tight_layout()
      
      
      

      # print('second column')
      
      if create_figure == True:
        # ax70.cla()
        # print(sigma_x_F_gamma_um_list)
        # print(fullycoherent_profile_min_list)
        ax70.scatter(sigma_x_F_gamma_um, fullycoherent_profile_min)
        ax70.set_xlim([sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max])
        ax70.set_ylim([-np.min(partiallycoherent_profile[200:-200]), np.min(partiallycoherent_profile[200:-200])])
        ax70.axhline(0, color='k')
        # plt.title('sigma_x_F_gamma=' + str(sigma_x_F_gamma_um) + ' sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min))






      n = partiallycoherent_profile.shape[0]
      xdata = np.linspace((-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3, n)

      if create_figure == True:
        ax.cla()
        ax.plot(xdata, partiallycoherent_profile, 'b-', label='measured partially coherent', linewidth=1)
        ax.plot(xdata, fullycoherent_profile, 'r-', label='recovered fully coherent', linewidth=1)
        # ax.plot(xdata, partiallycoherent_rec_profile_list[index_opt], 'g-', label='recovered partially coherent', linewidth=1)
        #plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
        ax.axhline(0, color='k')
        ax.set_xlabel('x / mm', fontsize = 8)
        ax.set_ylabel('Intensity / a.u.', fontsize = 8)
        # ax.set_xlim([xdata[0], xdata[-1]])
        # plt.legend()

        # plt.title('d / $\mu$m = '+str(int(separation_um)) + ' coherence length $\\xi_x$ / $\mu$m = ' + str(round(xi_x_um_list[index_opt],2)) + ' $\\xi_y$ / $\mu$m = ' + str(round(xi_y_um_list[index_opt],2)), fontsize=16)

        # see https://stackoverflow.com/a/29675706
        display(plt.gcf())
        clear_output(wait=True)
        # plt.show()

      if fullycoherent_profile_min<0:
        sigma_x_F_gamma_um = sigma_x_F_gamma_um/2
      else:
        sigma_x_F_gamma_um = sigma_x_F_gamma_um*1.2
      
      i = i + 1

    
            


    xdata = np.array(sigma_x_F_gamma_um_list)
    ydata = np.array(fullycoherent_profile_min_list)
    
    def func(x, a, b, c):
      return a*x**2 + b*x + c
    popt_func, pcov_func = curve_fit(func, xdata, ydata)
    a = popt_func[0]
    b = popt_func[1]
    c = popt_func[2]
  
    
    
    sigma_x_F_gamma_um_opt = brenth(func, np.min(xdata), np.max(xdata), args=(a,b,c))
    
    if create_figure == True:
      ax70.plot(np.array(sigma_x_F_gamma_um_list), func(np.array(sigma_x_F_gamma_um_list), a, b, c))
      ax70.axvline(sigma_x_F_gamma_um_opt)
    
    # display(plt.gcf())
    # clear_output(wait=True)
    # input("Press Enter to continue...")

    sigma_x_F_gamma = sigma_x_F_gamma_um_opt * 1e-6
    sigma_y_F_gamma = sigma_y_F_gamma_um * 1e-6
    F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma/dX_1, sigma_y_F_gamma/dX_1)
    #psf = gauss2d(X1_axis,Y1_axis,1.9)

    # Restore Image using Richardson-Lucy algorithm
    #fullycoherent = restoration.richardson_lucy(partiallycoherent, psf, 5)
    fullycoherent_opt = restoration.wiener(partiallycoherent, F_gamma, 1)
    #fullycoherent = np.real(deconvolve(partiallycoherent, psf))



    fullycoherent_opt = fullycoherent_opt / np.max(fullycoherent_opt[200:-200,200:-200])

    
    fullycoherent_profile_opt = np.mean(fullycoherent_opt[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
    #fullycoherent_profile = normalize(fullycoherent_profile)
    fullycoherent_profile_opt = fullycoherent_profile_opt / np.max(fullycoherent_profile_opt[200:-200]) # ignore what happens on the edges

    fullycoherent_profile_min_opt = np.min(fullycoherent_profile_opt[200:-200]) # ignore what happens on the edges
    

    # sigma_x_F_gamma_um_opt = sigma_x_F_gamma_um_list[i-1]
    # fullycoherent_opt = fullycoherent_list[i-1]
    fullycoherent_opt_list.append(fullycoherent_opt)
    # fullycoherent_profile_opt = fullycoherent_profile_list[i-1]
    fullycoherent_profile_opt_list.append(fullycoherent_profile_opt)
    # fullycoherent_profile_min_opt = fullycoherent_profile_min_list[i-1]
    # fullycoherent_profile_min_opt_list[j] = fullycoherent_profile_min_opt
    
    F_gamma = gauss2d(X1_axis/dX_1,Y1_axis/dY_1,sigma_x_F_gamma_um_opt*1e-6/dX_1, sigma_y_F_gamma_um*1e-6/dX_1)
    F_gamma_list.append(F_gamma)
    gamma = fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(F_gamma)))
    gamma_list.append(gamma)

    partiallycoherent_rec = np.abs(convolve(fullycoherent_opt,F_gamma))
    partiallycoherent_rec = normalize(partiallycoherent_rec)
    partiallycoherent_rec_list.append(partiallycoherent_rec)
    partiallycoherent_rec_profile = np.mean(partiallycoherent_rec[pixis_centery_px-int(profilewidth/2):pixis_centery_px+int(profilewidth/2),:], axis=0)
    partiallycoherent_rec_profile = normalize(partiallycoherent_rec_profile)
    partiallycoherent_rec_profile_list.append(partiallycoherent_rec_profile)
    # partiallycoherent_rec_profile_min_list[j] = np.min(partiallycoherent_rec_profile)
    partiallycoherent_rec_profile_min_list.append(np.min(partiallycoherent_rec_profile))
    #partiallycoherent_rec_profile = partiallycoherent_rec_profile / partiallycoherent_rec_profile[np.where(partiallycoherent_profile == 1.0)[0][0]]
    cor = corr2(partiallycoherent, partiallycoherent_rec)
    cor_profiles = corr2(partiallycoherent_profile, partiallycoherent_rec_profile)
    # cor_list[j] = corr2(partiallycoherent, partiallycoherent_rec)
    cor_list.append(corr2(partiallycoherent, partiallycoherent_rec))
    # cor_profiles_list[j] = cor_profiles
    cor_profiles_list.append(cor_profiles)
    #sigma_y_F_gamma_um_opt = sigma_y_F_gamma_um

    if create_figure == True:
      xdata = np.linspace((-n/2)*dX_1*1e3, (+n/2-1)*dX_1*1e3, n)
      ax.cla()
      ax.plot(xdata, partiallycoherent_profile, 'b-', label='measured partially coherent', linewidth=1)
      ax.plot(xdata, fullycoherent_profile_opt, 'r-', label='recovered fully coherent', linewidth=1)
      ax.plot(xdata, partiallycoherent_rec_profile_list[index_opt], 'g-', label='recovered partially coherent', linewidth=1)
      #plt.plot(xdata, gaussianbeam(xdata, 1, popt_gauss[0] ,popt_gauss[1], 0), 'r-', label='fit: m=%5.1f px, w=%5.1f px' % tuple([popt_gauss[0] ,popt_gauss[1]]))
      ax.axhline(0, color='k')
      ax.set_xlabel('x / mm', fontsize = 8)
      ax.set_ylabel('Intensity / a.u.', fontsize = 8)
      # ax.set_xlim([xdata[0], xdata[-1]])
    
    
    # delta_profiles_cropped_list[j] = np.sum(partiallycoherent_profile[crop_px:-crop_px] - partiallycoherent_rec_profile[crop_px:-crop_px])
    delta_profiles_cropped_list.append(np.sum(partiallycoherent_profile[crop_px:-crop_px] - partiallycoherent_rec_profile[crop_px:-crop_px]))
    
    
#         print('sigma_x_F_gamma_opt=' + str(sigma_x_F_gamma_um_opt) + 'sigma_y_F_gamma=' + str(sigma_y_F_gamma_um) + ' fullycoherent_profile_min=' + str(fullycoherent_profile_min_list[i-1]) + '\\' + ' correlation partiallycohernet measurement and reconstruction = ' + str(round(cor*100,2)) + '%')


    # determine chi2 distance
    number_of_bins = 100
    hist1, bin_edges1 = np.histogram(partiallycoherent.ravel(), bins=np.linspace(0,1,number_of_bins))
    hist2, bin_edges2 = np.histogram(partiallycoherent_rec.ravel(), bins=np.linspace(0,1,number_of_bins))
    # chi2distance_list[j] = chi2_distance(hist1, hist2)
    chi2distance_list.append(chi2_distance(hist1, hist2))

    index_opt = np.where(chi2distance_list == np.nanmin(chi2distance_list))[0][0]


    # determine difference of miniumum of measured and reconstructed profile
    # delta_rec_min_list[j] = np.min(partiallycoherent_rec_profile) - np.min(partiallycoherent_profile)
    delta_rec_min_list.append(np.min(partiallycoherent_rec_profile) - np.min(partiallycoherent_profile))

    

    xdata = list(range(n))
    ydata = fullycoherent[pixis_centery_px,:]
    ydata = ydata / np.max(ydata)
    

    
    abs_gamma = np.abs(gamma)
    abs_gamma = abs_gamma / np.max(abs_gamma)
    abs_gamma_list.append(abs_gamma)
    xdata = list(range(n))
    ydata = abs_gamma[int(n/2),:]
    p0 = (int(n/2), 1)
    try:
      popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
    except:
      1
    xi_x_px = popt_gauss[1]/2
    xi_x_um = xi_x_px * dX_2 * 1e6
    # xi_x_um_list[j] = xi_x_um
    xi_x_um_list.append(xi_x_um)
    
    
    xdata = list(range(n))
    ydata = abs_gamma[:,int(n/2)]
    p0 = (int(n/2), 1)
    try:
      popt_gauss, pcov_gaussian = curve_fit(lambda x, m, w: gaussianbeam(x, 1, m ,w, 0), xdata, ydata, p0)
    except:
      1
    xi_y_px = popt_gauss[1]/2
    xi_y_um = xi_y_px * dX_2 * 1e6
    # xi_y_um_list[j] = xi_y_um
    xi_y_um_list.append(xi_y_um)
    
    #print('coherence length xi/um = ' + str(xi_um))


    if create_figure == True:
      ax00.scatter(sigma_y_F_gamma_um_list[j], cor_list[j])
      ax00.set_ylabel('cor')
      ax00.axvline(sigma_y_F_gamma_um_list[index_opt])
      ax00.set_xlim([sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max])

      
      ax10.scatter(sigma_y_F_gamma_um_list[j], cor_profiles_list[j])
      ax10.set_ylabel('cor profiles')
      ax10.axvline(sigma_y_F_gamma_um_list[index_opt])
      ax10.set_xlim([sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max])

      
      ax20.scatter(sigma_y_F_gamma_um_list[j], chi2distance_list[j])
      ax20.set_ylabel('chi2distance')
      ax20.axvline(sigma_y_F_gamma_um_list[index_opt])
      ax20.set_xlim([sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max])

      
      ax30.scatter(sigma_y_F_gamma_um_list[j], delta_rec_min_list[j])
      ax30.set_ylabel('delta minimum')
      ax30.set_xlim([sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max])

      
      ax40.scatter(sigma_y_F_gamma_um_list[j], delta_profiles_cropped_list[j])
      ax40.axvline(sigma_y_F_gamma_um_list[index_opt])
      ax40.set_ylabel('delta profiles cropped')
      ax40.set_xlim([sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max])

      
      ax50.scatter(sigma_y_F_gamma_um_list[j], xi_x_um_list[j])
      ax50.set_ylabel('xi_x')
      ax50.axvline(sigma_y_F_gamma_um_list[index_opt])
      ax50.set_xlim([sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max])

      
      ax60.scatter(sigma_y_F_gamma_um_list[j], xi_y_um_list[j])
      ax60.set_ylabel('xi_y')
      ax60.axvline(sigma_y_F_gamma_um_list[index_opt])
      ax60.set_xlim([sigma_x_F_gamma_um_min, sigma_x_F_gamma_um_max])

      display(plt.gcf())
      clear_output(wait=True)


        
        # if j == 0:
        #   sigma_y_F_gamma_um = sigma_y_F_gamma_um * 1.3

        # else:
        #   stepsize = (sigma_y_F_gamma_um_list[1] - sigma_y_F_gamma_um_list[0])
        #   if chi2distance_list[j] > chi2distance_list[j-1]:
        #     sigma_y_F_gamma_um = sigma_y_F_gamma_um_list[j] - stepsize
        #   else:
        #     sigma_y_F_gamma_um = sigma_y_F_gamma_um_list[j] + stepsize
        #   # sigma_y_F_gamma_um = sigma_y_F_gamma_um_list[j] - ( chi2distance_list[j-1] - chi2distance_list[j] ) / (sigma_y_F_gamma_um_list[j-1] - sigma_y_F_gamma_um_list[j]) * (sigma_y_F_gamma_um_list[1] - sigma_y_F_gamma_um_list[0])


        # j = j+1
        
        
    
    # index_opt = np.where( np.abs(partiallycoherent_rec_profile_min_list - np.min(partiallycoherent_profile)) == np.min(np.abs(partiallycoherent_rec_profile_min_list - np.min(partiallycoherent_profile)) ) )[0][0]
    
        
    A_bp = fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(np.sqrt(partiallycoherent))))  # amplitude
    I_bp = np.abs(A_bp)**2  # intensity
    
    return (partiallycoherent_profile, fullycoherent_opt_list, fullycoherent_profile_opt_list,  partiallycoherent_rec_list, partiallycoherent_rec_profile_list, partiallycoherent_rec_profile_min_list, delta_rec_min_list, delta_profiles_cropped_list, sigma_x_F_gamma_um_opt, sigma_y_F_gamma_um_list, F_gamma_list, abs_gamma_list, xi_x_um_list, xi_y_um_list, I_bp, dX_2, cor_list, cor_profiles_list, cor_profiles_list, index_opt, chi2distance_list)

do_deconvmethod = True
savefigure = False

#imageid = imageid_widget.value

imageid_excluded = []

if do_deconvmethod == True:

    count = 0

    from datetime import datetime

    time_taken = 0

    with h5py.File(dph_settings_bgsubtracted_widget.label, 'r') as hdf5_file:
      imageids = hdf5_file['/bgsubtracted/imageid'][:]
    for imageid in [imageids[0]]:
    # for imageid in imageids:
        
        
        hdf5_file_path = dph_settings_bgsubtracted_widget.value
        with h5py.File(hdf5_file_path, 'r') as hdf5_file:
          pixis_image_norm = hdf5_file['/bgsubtracted/pixis_image_norm'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
          pixis_profile_avg = hdf5_file['/bgsubtracted/pixis_profile_avg'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
          timestamp_pulse_id = hdf5_file['Timing/time stamp/fl2user1'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][2]
          pixis_centery_px = hdf5_file['/bgsubtracted/pixis_centery_px'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][0]
          print(pixis_centery_px)

        ph = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['pinholes'].iloc[0]
        separation_um = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['separation_um'].iloc[0]
        orientation = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['orientation'].iloc[0]
        setting_wavelength_nm = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0]
        energy_hall_uJ = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['energy hall'].iloc[0]
        _lambda_nm_fit = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0] # is this stored in df0? get it from profile_fitting?
        
        hdf5_file_name_image = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['hdf5_file_name'].iloc[0]
        pixis_avg_width = 200 # random number, store in hdf5?
        beamposition_horizontal_interval = 1000 # random number, store in hdf5?
        
        

        count = count + 1
        time_left = (len(imageids) + 1 - count) * time_taken

        start = datetime.now()

        z = 5781 * 1e-3
        z_0 = 1067 * 1e-3
        z_T = z + z_0
        z_eff = z * z_0 / (z_T)
        dX_1 = 13 * 1e-6

        print('imageid=' + str(imageid) + ' ' + str(round(count/(len(imageids)+1)*100,2)) +'% ' + str('time left=') + str(time_left)  + ' lambda_nm_fit='+str(_lambda_nm_fit))
        #sigma_F_gamma_um_max = 60
        #partiallycoherent_profile, fullycoherent, fullycoherent_profile, partiallycoherent_rec_profile, partiallycoherent_rec_profile, sigma_F_gamma_um_opt, F_gamma, abs_gamma, xi_um, I_bp, dX_2, cor = deconvmethod(partiallycoherent, z, dX_1, pixis_avg_width, int(pixis_centery_px),_lambda_nm_fit[imageid]*1e-9, sigma_F_gamma_um_max)

        # How to guess these time-savingly???
        sigma_x_F_gamma_um_guess = 17
        sigma_x_F_gamma_um_min = sigma_x_F_gamma_um_guess/2
        sigma_x_F_gamma_um_max = sigma_x_F_gamma_um_guess*2
        sigma_x_F_gamma_um_stepsize = 2


        sigma_y_F_gamma_um_guess = 14
        sigma_y_F_gamma_um_min = sigma_y_F_gamma_um_guess - 8
        sigma_y_F_gamma_um_max = sigma_y_F_gamma_um_guess + 8
        sigma_y_F_gamma_um_stepsize = 2

        partiallycoherent = pixis_image_norm
        #pixis_profile_avg_dataset[imageid]
        
        xi_um_guess = 411
        sigma_y_F_gamma_um_guess = calc_sigma_F_gamma_um(xi_um_guess, n, dX_1, wavelength*1e9, False) 
        (
            partiallycoherent_profile,
            fullycoherent_opt_list,
            fullycoherent_profile_opt_list,
            partiallycoherent_rec_list,
            partiallycoherent_rec_profile_list,
            partiallycoherent_rec_profile_min_list,
            delta_rec_min_list,
            delta_profiles_cropped_list,
            sigma_x_F_gamma_um_opt,
            sigma_y_F_gamma_um_list,
            F_gamma_list,
            abs_gamma_list,
            xi_x_um_list,
            xi_y_um_list,
            I_bp,
            dX_2,
            cor_list,
            cor_profiles_list,
            cor_profiles_cropped_list,
            index_opt,
            chi2distance_list,
        ) = deconvmethod_2d_x(
            partiallycoherent,
            z,
            dX_1,
            pixis_avg_width,
            int(pixis_centery_px),
            _lambda_nm_fit * 1e-9,
            sigma_x_F_gamma_um_min,
            sigma_x_F_gamma_um_max,
            sigma_y_F_gamma_um_min,
            sigma_y_F_gamma_um_max,
            sigma_y_F_gamma_um_stepsize,
            sigma_y_F_gamma_um_stepsize,
            sigma_y_F_gamma_um_guess,
            xi_um_guess,
            200,
            create_figure = True
        )



        end = datetime.now()
        time_taken = end - start
        # print(time_taken)

 
        gc.collect()

display(Javascript('''google.colab.output.setIframeHeight(0, true, {maxHeight: 5000})''')) # https://stackoverflow.com/a/57346765

"""### only calc chi2distance for a given y"""

def calc_chi2distance(sigma_y_F_gamma_um_guess):
  (
          partiallycoherent_profile,
          fullycoherent_opt_list,
          fullycoherent_profile_opt_list,
          partiallycoherent_rec_list,
          partiallycoherent_rec_profile_list,
          partiallycoherent_rec_profile_min_list,
          delta_rec_min_list,
          delta_profiles_cropped_list,
          sigma_x_F_gamma_um_opt,
          sigma_y_F_gamma_um_list,
          F_gamma_list,
          abs_gamma_list,
          xi_x_um_list,
          xi_y_um_list,
          I_bp,
          dX_2,
          cor_list,
          cor_profiles_list,
          cor_profiles_cropped_list,
          index_opt,
          chi2distance_list,
      ) = deconvmethod_2d_x(
          partiallycoherent,
          z,
          dX_1,
          pixis_avg_width,
          int(pixis_centery_px),
          _lambda_nm_fit * 1e-9,
          sigma_x_F_gamma_um_min,
          sigma_x_F_gamma_um_max,
          sigma_y_F_gamma_um_min,
          sigma_y_F_gamma_um_max,
          sigma_y_F_gamma_um_stepsize,
          sigma_y_F_gamma_um_stepsize,
          sigma_y_F_gamma_um_guess,
          xi_um_guess,
          200,
      )
  return chi2distance_list[0]

do_deconvmethod = True
savefigure = False

#imageid = imageid_widget.value

imageid_excluded = []

if do_deconvmethod == True:

    count = 0

    from datetime import datetime

    time_taken = 0

    with h5py.File(dph_settings_bgsubtracted_widget.label, 'r') as hdf5_file:
      imageids = hdf5_file['/bgsubtracted/imageid'][:]
    for imageid in [imageids[0]]:
    # for imageid in imageids:
        
        
        hdf5_file_path = dph_settings_bgsubtracted_widget.value
        with h5py.File(hdf5_file_path, 'r') as hdf5_file:
          pixis_image_norm = hdf5_file['/bgsubtracted/pixis_image_norm'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
          pixis_profile_avg = hdf5_file['/bgsubtracted/pixis_profile_avg'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
          timestamp_pulse_id = hdf5_file['Timing/time stamp/fl2user1'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][2]
          pixis_centery_px = hdf5_file['/bgsubtracted/pixis_centery_px'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][0]
          print(pixis_centery_px)

        ph = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['pinholes'].iloc[0]
        separation_um = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['separation_um'].iloc[0]
        orientation = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['orientation'].iloc[0]
        setting_wavelength_nm = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0]
        energy_hall_uJ = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['energy hall'].iloc[0]
        _lambda_nm_fit = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0] # is this stored in df0? get it from profile_fitting?
        
        hdf5_file_name_image = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['hdf5_file_name'].iloc[0]
        pixis_avg_width = 200 # random number, store in hdf5?
        beamposition_horizontal_interval = 1000 # random number, store in hdf5?
        
        

        count = count + 1
        time_left = (len(imageids) + 1 - count) * time_taken

        start = datetime.now()

        z = 5781 * 1e-3
        z_0 = 1067 * 1e-3
        z_T = z + z_0
        z_eff = z * z_0 / (z_T)
        dX_1 = 13 * 1e-6

        print('imageid=' + str(imageid) + ' ' + str(round(count/(len(imageids)+1)*100,2)) +'% ' + str('time left=') + str(time_left)  + ' lambda_nm_fit='+str(_lambda_nm_fit))
        #sigma_F_gamma_um_max = 60
        #partiallycoherent_profile, fullycoherent, fullycoherent_profile, partiallycoherent_rec_profile, partiallycoherent_rec_profile, sigma_F_gamma_um_opt, F_gamma, abs_gamma, xi_um, I_bp, dX_2, cor = deconvmethod(partiallycoherent, z, dX_1, pixis_avg_width, int(pixis_centery_px),_lambda_nm_fit[imageid]*1e-9, sigma_F_gamma_um_max)

        # How to guess these time-savingly???
        sigma_x_F_gamma_um_guess = 17
        sigma_x_F_gamma_um_min = sigma_x_F_gamma_um_guess/2
        sigma_x_F_gamma_um_max = sigma_x_F_gamma_um_guess*2
        sigma_x_F_gamma_um_stepsize = 2


        sigma_y_F_gamma_um_guess = 14
        sigma_y_F_gamma_um_min = sigma_y_F_gamma_um_guess - 8
        sigma_y_F_gamma_um_max = sigma_y_F_gamma_um_guess + 8
        sigma_y_F_gamma_um_stepsize = 2

        partiallycoherent = pixis_image_norm
        #pixis_profile_avg_dataset[imageid]
        
        xi_um_guess = 411
        sigma_y_F_gamma_um_guess = calc_sigma_F_gamma_um(xi_um_guess, n, dX_1, wavelength*1e9, False) 
        chi2distance = calc_chi2distance(sigma_y_F_gamma_um_guess)

        print(chi2distance)



        end = datetime.now()
        time_taken = end - start
        # print(time_taken)

 
        gc.collect()

display(Javascript('''google.colab.output.setIframeHeight(0, true, {maxHeight: 5000})''')) # https://stackoverflow.com/a/57346765

def calc_chi2distance(sigma_y_F_gamma_um_guess):
  (
          partiallycoherent_profile,
          fullycoherent_opt_list,
          fullycoherent_profile_opt_list,
          partiallycoherent_rec_list,
          partiallycoherent_rec_profile_list,
          partiallycoherent_rec_profile_min_list,
          delta_rec_min_list,
          delta_profiles_cropped_list,
          sigma_x_F_gamma_um_opt,
          sigma_y_F_gamma_um_list,
          F_gamma_list,
          abs_gamma_list,
          xi_x_um_list,
          xi_y_um_list,
          I_bp,
          dX_2,
          cor_list,
          cor_profiles_list,
          cor_profiles_cropped_list,
          index_opt,
          chi2distance_list,
      ) = deconvmethod_2d_x(
          partiallycoherent,
          z,
          dX_1,
          pixis_avg_width,
          int(pixis_centery_px),
          _lambda_nm_fit * 1e-9,
          sigma_x_F_gamma_um_min,
          sigma_x_F_gamma_um_max,
          sigma_y_F_gamma_um_min,
          sigma_y_F_gamma_um_max,
          sigma_y_F_gamma_um_stepsize,
          sigma_y_F_gamma_um_stepsize,
          sigma_y_F_gamma_um_guess,
          xi_um_guess,
          200,
          create_figure = True
      )
  return chi2distance_list[0]

do_deconvmethod = True
savefigure = False

#imageid = imageid_widget.value

imageid_excluded = []

if do_deconvmethod == True:

    count = 0

    from datetime import datetime

    time_taken = 0

    with h5py.File(dph_settings_bgsubtracted_widget.label, 'r') as hdf5_file:
      imageids = hdf5_file['/bgsubtracted/imageid'][:]
    for imageid in [imageids[0]]:
    # for imageid in imageids:
        
        
        hdf5_file_path = dph_settings_bgsubtracted_widget.value
        with h5py.File(hdf5_file_path, 'r') as hdf5_file:
          pixis_image_norm = hdf5_file['/bgsubtracted/pixis_image_norm'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
          pixis_profile_avg = hdf5_file['/bgsubtracted/pixis_profile_avg'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
          timestamp_pulse_id = hdf5_file['Timing/time stamp/fl2user1'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][2]
          pixis_centery_px = hdf5_file['/bgsubtracted/pixis_centery_px'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][0]
          print(pixis_centery_px)

        ph = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['pinholes'].iloc[0]
        separation_um = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['separation_um'].iloc[0]
        orientation = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['orientation'].iloc[0]
        setting_wavelength_nm = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0]
        energy_hall_uJ = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['energy hall'].iloc[0]
        _lambda_nm_fit = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0] # is this stored in df0? get it from profile_fitting?
        
        hdf5_file_name_image = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['hdf5_file_name'].iloc[0]
        pixis_avg_width = 200 # random number, store in hdf5?
        beamposition_horizontal_interval = 1000 # random number, store in hdf5?
        
        

        count = count + 1
        time_left = (len(imageids) + 1 - count) * time_taken

        start = datetime.now()

        z = 5781 * 1e-3
        z_0 = 1067 * 1e-3
        z_T = z + z_0
        z_eff = z * z_0 / (z_T)
        dX_1 = 13 * 1e-6

        print('imageid=' + str(imageid) + ' ' + str(round(count/(len(imageids)+1)*100,2)) +'% ' + str('time left=') + str(time_left)  + ' lambda_nm_fit='+str(_lambda_nm_fit))
        #sigma_F_gamma_um_max = 60
        #partiallycoherent_profile, fullycoherent, fullycoherent_profile, partiallycoherent_rec_profile, partiallycoherent_rec_profile, sigma_F_gamma_um_opt, F_gamma, abs_gamma, xi_um, I_bp, dX_2, cor = deconvmethod(partiallycoherent, z, dX_1, pixis_avg_width, int(pixis_centery_px),_lambda_nm_fit[imageid]*1e-9, sigma_F_gamma_um_max)

        # How to guess these time-savingly???
        sigma_x_F_gamma_um_guess = 17
        sigma_x_F_gamma_um_min = sigma_x_F_gamma_um_guess/2
        sigma_x_F_gamma_um_max = sigma_x_F_gamma_um_guess*2
        sigma_x_F_gamma_um_stepsize = 2


        sigma_y_F_gamma_um_guess = 14
        sigma_y_F_gamma_um_min = sigma_y_F_gamma_um_guess - 8
        sigma_y_F_gamma_um_max = sigma_y_F_gamma_um_guess + 8
        sigma_y_F_gamma_um_stepsize = 2

        partiallycoherent = pixis_image_norm
        #pixis_profile_avg_dataset[imageid]
        
        xi_um_guess = 411
        sigma_y_F_gamma_um_guess = calc_sigma_F_gamma_um(xi_um_guess, n, dX_1, wavelength*1e9, False) 
        chi2distance_opt = minimize_scalar(calc_chi2distance, bounds=(sigma_y_F_gamma_um_guess/2,sigma_y_F_gamma_um_guess*2), method='bounded', options={'disp': True, 'maxiter': 5} )
        # see https://stackoverflow.com/questions/16739065/how-to-display-progress-of-scipy-optimize-function

        print(chi2distance_opt)



        end = datetime.now()
        time_taken = end - start
        # print(time_taken)

 
        gc.collect()

display(Javascript('''google.colab.output.setIframeHeight(0, true, {maxHeight: 5000})''')) # https://stackoverflow.com/a/57346765

"""### use sciypy.optimize to scan y"""

def calc_chi2distance(sigma_y_F_gamma_um_guess):
  (
          partiallycoherent_profile,
          fullycoherent_opt_list,
          fullycoherent_profile_opt_list,
          partiallycoherent_rec_list,
          partiallycoherent_rec_profile_list,
          partiallycoherent_rec_profile_min_list,
          delta_rec_min_list,
          delta_profiles_cropped_list,
          sigma_x_F_gamma_um_opt,
          sigma_y_F_gamma_um_list,
          F_gamma_list,
          abs_gamma_list,
          xi_x_um_list,
          xi_y_um_list,
          I_bp,
          dX_2,
          cor_list,
          cor_profiles_list,
          cor_profiles_cropped_list,
          index_opt,
          chi2distance_list,
      ) = deconvmethod_2d_x(
          partiallycoherent,
          z,
          dX_1,
          pixis_avg_width,
          int(pixis_centery_px),
          _lambda_nm_fit * 1e-9,
          sigma_x_F_gamma_um_min,
          sigma_x_F_gamma_um_max,
          sigma_y_F_gamma_um_min,
          sigma_y_F_gamma_um_max,
          sigma_y_F_gamma_um_stepsize,
          sigma_y_F_gamma_um_stepsize,
          sigma_y_F_gamma_um_guess,
          xi_um_guess,
          200,
          create_figure
      )
  return chi2distance_list[0]

# adapted from https://stackoverflow.com/a/54791154
def minimize_and_store(x0, f):
  all_x_i = [x0]
  all_f_i = [f(x0)]
  def store_to_array(X):
    print(X)
    all_x_i.append(X)
    all_f_i.append(f(X))
  optimize.minimize(calc_chi2distance, x0, callback=store_to_array, options={'disp': True, 'maxiter': 5} )
  return all_x_i, all_f_i



do_deconvmethod = True
savefigure = False

#imageid = imageid_widget.value

imageid_excluded = []

if do_deconvmethod == True:

    count = 0

    from datetime import datetime

    time_taken = 0

    with h5py.File(dph_settings_bgsubtracted_widget.label, 'r') as hdf5_file:
      imageids = hdf5_file['/bgsubtracted/imageid'][:]
    for imageid in [imageids[0]]:
    # for imageid in imageids:
        
        
        hdf5_file_path = dph_settings_bgsubtracted_widget.value
        with h5py.File(hdf5_file_path, 'r') as hdf5_file:
          pixis_image_norm = hdf5_file['/bgsubtracted/pixis_image_norm'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
          pixis_profile_avg = hdf5_file['/bgsubtracted/pixis_profile_avg'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]]
          timestamp_pulse_id = hdf5_file['Timing/time stamp/fl2user1'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][2]
          pixis_centery_px = hdf5_file['/bgsubtracted/pixis_centery_px'][np.where(hdf5_file['/bgsubtracted/imageid'][:]==imageid)[0][0]][0]
          print(pixis_centery_px)

        ph = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['pinholes'].iloc[0]
        separation_um = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['separation_um'].iloc[0]
        orientation = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['orientation'].iloc[0]
        setting_wavelength_nm = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0]
        energy_hall_uJ = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['energy hall'].iloc[0]
        _lambda_nm_fit = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['setting_wavelength_nm'].iloc[0] # is this stored in df0? get it from profile_fitting?
        
        hdf5_file_name_image = df0[df0['timestamp_pulse_id']==timestamp_pulse_id]['hdf5_file_name'].iloc[0]
        pixis_avg_width = 200 # random number, store in hdf5?
        beamposition_horizontal_interval = 1000 # random number, store in hdf5?
        
        

        count = count + 1
        time_left = (len(imageids) + 1 - count) * time_taken

        

        z = 5781 * 1e-3
        z_0 = 1067 * 1e-3
        z_T = z + z_0
        z_eff = z * z_0 / (z_T)
        dX_1 = 13 * 1e-6

        print('imageid=' + str(imageid) + ' ' + str(round(count/(len(imageids)+1)*100,2)) +'% ' + str('time left=') + str(time_left)  + ' lambda_nm_fit='+str(_lambda_nm_fit))
        #sigma_F_gamma_um_max = 60
        #partiallycoherent_profile, fullycoherent, fullycoherent_profile, partiallycoherent_rec_profile, partiallycoherent_rec_profile, sigma_F_gamma_um_opt, F_gamma, abs_gamma, xi_um, I_bp, dX_2, cor = deconvmethod(partiallycoherent, z, dX_1, pixis_avg_width, int(pixis_centery_px),_lambda_nm_fit[imageid]*1e-9, sigma_F_gamma_um_max)

        # How to guess these time-savingly???
        sigma_x_F_gamma_um_guess = 17
        sigma_x_F_gamma_um_min = sigma_x_F_gamma_um_guess/2
        sigma_x_F_gamma_um_max = sigma_x_F_gamma_um_guess*2
        sigma_x_F_gamma_um_stepsize = 2


        sigma_y_F_gamma_um_guess = 14
        sigma_y_F_gamma_um_min = sigma_y_F_gamma_um_guess - 8
        sigma_y_F_gamma_um_max = sigma_y_F_gamma_um_guess + 8
        sigma_y_F_gamma_um_stepsize = 2

        partiallycoherent = pixis_image_norm
        #pixis_profile_avg_dataset[imageid]
        
        xi_um_guess = 475
        sigma_y_F_gamma_um_guess = calc_sigma_F_gamma_um(xi_um_guess, n, dX_1, wavelength*1e9, False) 
        print('sigma_y_F_gamma_um_guess='+str(sigma_y_F_gamma_um_guess))
        create_figure = False




        # chi2distance_minimize_result = minimize_and_store(sigma_y_F_gamma_um_guess, calc_chi2distance)
        start = datetime.now()
        chi2distance_minimize_result_bounded = optimize.minimize_scalar(calc_chi2distance, bounds = [sigma_y_F_gamma_um_guess/4,sigma_y_F_gamma_um_guess*2], method='bounded', options={'disp': 3, 'maxiter': 50, 'xatol': 1e-1} )
        end = datetime.now()
        time_taken = end - start
        print(time_taken)

        start = datetime.now()
        chi2distance_minimize_result_brent = optimize.minimize_scalar(calc_chi2distance, bracket = [sigma_y_F_gamma_um_guess/4,sigma_y_F_gamma_um_guess*2], method='brent', options={'maxiter': 50, 'xtol': 1e-1} )
        end = datetime.now()
        time_taken = end - start
        print(time_taken)
        # see https://stackoverflow.com/questions/16739065/how-to-display-progress-of-scipy-optimize-function



 
        gc.collect()

display(Javascript('''google.colab.output.setIframeHeight(0, true, {maxHeight: 5000})''')) # https://stackoverflow.com/a/57346765

chi2distance_minimize_result_bounded

chi2distance_minimize_result_brent

